"""
L1 Feature Calculation Pipeline Contracts
==========================================

Pydantic contracts for Layer 1 (Feature Calculation) data flows.
Ensures type safety and validation for feature calculation operations.

Contract: CTR-L1-001

Architecture:
    L0 (Data) → L1 (Feature Calculation) → L2 (Preprocessing) / L5 (Inference)

Data Flow:
    usdcop_m5_ohlcv + macro_indicators_daily → Feature Calculation → inference_features_5m

Features Calculated (13 core):
    - Returns: log_ret_5m, log_ret_1h, log_ret_4h
    - Technical: rsi_9, atr_pct, adx_14
    - Macro Z-scores: dxy_z, vix_z, embi_z
    - Macro changes: dxy_change_1d, brent_change_1d
    - Derived: rate_spread, usdmxn_change_1d

Version: 1.0.0
Author: Generated by Contract System
"""

from __future__ import annotations

import datetime as dt
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Tuple, Union

import numpy as np
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    field_validator,
    model_validator,
)


# =============================================================================
# ENUMS
# =============================================================================


class L1XComKeys(str, Enum):
    """XCom keys for L1 inter-task communication.

    Contract: CTR-L1-XCOM-001
    """
    # Feature calculation
    FEATURES_COUNT = "features_count"
    MACRO_ROWS_USED = "macro_rows_used"
    DETECTED_OHLCV_TIME = "detected_ohlcv_time"
    LAST_PROCESSED_OHLCV_TIME = "last_processed_ohlcv_time"

    # Validation
    LATEST_OHLCV = "latest_ohlcv"
    LATEST_FEATURE = "latest_feature"
    RECENT_FEATURES = "recent_features"
    INVALID_TRADING_DATES = "invalid_trading_dates"


class FeatureCalculationStatus(str, Enum):
    """Status of feature calculation task."""
    SUCCESS = "success"
    ERROR = "error"
    WARNING = "warning"
    INSUFFICIENT_DATA = "insufficient_data"
    STALE_DATA = "stale_data"


class FeatureType(str, Enum):
    """Feature type categories."""
    RETURN = "return"
    TECHNICAL = "technical"
    MACRO_ZSCORE = "macro_zscore"
    MACRO_CHANGE = "macro_change"
    DERIVED = "derived"


# =============================================================================
# FEATURE DEFINITIONS
# =============================================================================


class FeatureDefinition(BaseModel):
    """Definition of a single feature.

    Contract: CTR-L1-DEF-001
    """
    model_config = ConfigDict(frozen=True)

    name: str = Field(..., description="Feature name")
    feature_type: FeatureType
    description: str = Field(default="")
    period: Optional[int] = Field(default=None, description="Lookback period if applicable")
    warmup_bars: int = Field(default=0, ge=0, description="Bars needed for warmup")

    # Normalization parameters
    norm_mean: Optional[float] = Field(default=None)
    norm_std: Optional[float] = Field(default=None)
    clip_min: Optional[float] = Field(default=None)
    clip_max: Optional[float] = Field(default=None)


# Core feature definitions
CORE_FEATURE_DEFINITIONS: List[FeatureDefinition] = [
    # Returns
    FeatureDefinition(
        name="log_ret_5m",
        feature_type=FeatureType.RETURN,
        description="5-minute log return",
        period=1,
        warmup_bars=1
    ),
    FeatureDefinition(
        name="log_ret_1h",
        feature_type=FeatureType.RETURN,
        description="1-hour log return (12 bars)",
        period=12,
        warmup_bars=12
    ),
    FeatureDefinition(
        name="log_ret_4h",
        feature_type=FeatureType.RETURN,
        description="4-hour log return (48 bars)",
        period=48,
        warmup_bars=48
    ),

    # Technical indicators
    FeatureDefinition(
        name="rsi_9",
        feature_type=FeatureType.TECHNICAL,
        description="RSI with 9-period",
        period=9,
        warmup_bars=10,
        clip_min=0.0,
        clip_max=100.0
    ),
    FeatureDefinition(
        name="atr_pct",
        feature_type=FeatureType.TECHNICAL,
        description="ATR as percentage of close",
        period=10,
        warmup_bars=11
    ),
    FeatureDefinition(
        name="adx_14",
        feature_type=FeatureType.TECHNICAL,
        description="ADX with 14-period",
        period=14,
        warmup_bars=28,  # ADX needs 2x period
        clip_min=0.0,
        clip_max=100.0
    ),

    # Macro Z-scores
    FeatureDefinition(
        name="dxy_z",
        feature_type=FeatureType.MACRO_ZSCORE,
        description="Dollar Index z-score",
        norm_mean=103.5,
        norm_std=2.5
    ),
    FeatureDefinition(
        name="dxy_change_1d",
        feature_type=FeatureType.MACRO_CHANGE,
        description="DXY daily change",
        warmup_bars=1
    ),
    FeatureDefinition(
        name="vix_z",
        feature_type=FeatureType.MACRO_ZSCORE,
        description="VIX z-score",
        norm_mean=18.0,
        norm_std=5.0
    ),
    FeatureDefinition(
        name="embi_z",
        feature_type=FeatureType.MACRO_ZSCORE,
        description="EMBI Colombia z-score",
        norm_mean=400.0,
        norm_std=50.0
    ),
    FeatureDefinition(
        name="brent_change_1d",
        feature_type=FeatureType.MACRO_CHANGE,
        description="Brent oil daily change",
        warmup_bars=1
    ),
    FeatureDefinition(
        name="rate_spread",
        feature_type=FeatureType.DERIVED,
        description="10Y - 2Y Treasury spread"
    ),
    FeatureDefinition(
        name="usdmxn_change_1d",
        feature_type=FeatureType.MACRO_CHANGE,
        description="USD/MXN daily change",
        warmup_bars=12
    ),
]


class FeatureContract(BaseModel):
    """Feature contract with 13 core features.

    Contract: CTR-L1-CONTRACT-001
    """
    model_config = ConfigDict(frozen=True)

    version: str = Field(default="current")
    core_feature_count: int = Field(default=13)
    state_feature_count: int = Field(default=2)
    total_observation_dim: int = Field(default=15)

    feature_order: Tuple[str, ...] = Field(
        default=(
            "log_ret_5m", "log_ret_1h", "log_ret_4h",
            "rsi_9", "atr_pct", "adx_14",
            "dxy_z", "dxy_change_1d", "vix_z", "embi_z",
            "brent_change_1d", "rate_spread", "usdmxn_change_1d",
        )
    )

    min_warmup_bars: int = Field(
        default=50,
        description="Minimum bars for indicator warmup"
    )

    @property
    def feature_definitions(self) -> List[FeatureDefinition]:
        """Get all feature definitions."""
        return CORE_FEATURE_DEFINITIONS


# Singleton instance
FEATURE_CONTRACT = FeatureContract()


# =============================================================================
# INPUT CONTRACTS
# =============================================================================


class OHLCVInput(BaseModel):
    """OHLCV data input for feature calculation.

    Contract: CTR-L1-INPUT-001
    """
    time: dt.datetime
    open: float
    high: float
    low: float
    close: float
    volume: float = Field(default=0.0)

    @field_validator("close", "open", "high", "low")
    @classmethod
    def validate_positive_price(cls, v: float) -> float:
        if v <= 0:
            raise ValueError("Price must be positive")
        return v


class OHLCVBatchInput(BaseModel):
    """Batch of OHLCV records for feature calculation.

    Contract: CTR-L1-INPUT-002
    """
    records: List[OHLCVInput] = Field(..., min_length=1)
    symbol: str = Field(default="USD/COP")

    @property
    def bar_count(self) -> int:
        return len(self.records)

    @property
    def has_sufficient_warmup(self) -> bool:
        """Check if batch has enough bars for indicator warmup."""
        return self.bar_count >= FEATURE_CONTRACT.min_warmup_bars

    @property
    def time_range(self) -> Tuple[dt.datetime, dt.datetime]:
        """Get time range of batch."""
        times = [r.time for r in self.records]
        return min(times), max(times)


class MacroInput(BaseModel):
    """Macro indicator input for feature calculation.

    Contract: CTR-L1-INPUT-003
    Source: macro_indicators_daily via FFILL
    """
    date: dt.date
    dxy: Optional[float] = Field(default=None)
    vix: Optional[float] = Field(default=None)
    embi: Optional[float] = Field(default=None)
    brent: Optional[float] = Field(default=None)
    treasury_2y: Optional[float] = Field(default=None)
    treasury_10y: Optional[float] = Field(default=None)
    usdmxn: Optional[float] = Field(default=None)

    @property
    def can_calculate_features(self) -> bool:
        """Check if minimum required macro data is available."""
        return self.dxy is not None and self.vix is not None


class MacroZScoreConfig(BaseModel):
    """Configuration for macro z-score calculation.

    Contract: CTR-L1-CONFIG-001
    """
    dxy_mean: float = Field(default=103.5)
    dxy_std: float = Field(default=2.5)
    vix_mean: float = Field(default=18.0)
    vix_std: float = Field(default=5.0)
    embi_mean: float = Field(default=400.0)
    embi_std: float = Field(default=50.0)


# =============================================================================
# Z-SCORE METHOD CONFIGURATION
# =============================================================================


class ZScoreMethod(str, Enum):
    """Method for calculating z-scores.

    Contract: CTR-L1-ZSCORE-001
    """
    STATIC = "static"           # Fixed mean/std from training
    ROLLING = "rolling"         # Rolling window calculation
    EXPANDING = "expanding"     # Expanding window from start date


class ZScoreConfig(BaseModel):
    """Unified z-score configuration for training and inference parity.

    Contract: CTR-L1-ZSCORE-002
    Ensures consistency between training and inference z-score calculations.
    """
    model_config = ConfigDict(frozen=True)

    method: ZScoreMethod = Field(default=ZScoreMethod.STATIC)

    # Static parameters (used when method=STATIC)
    static_params: Dict[str, Dict[str, float]] = Field(
        default_factory=lambda: {
            "dxy": {"mean": 103.5, "std": 2.5},
            "vix": {"mean": 18.0, "std": 5.0},
            "embi": {"mean": 400.0, "std": 50.0},
        }
    )

    # Rolling parameters (used when method=ROLLING)
    rolling_window_days: int = Field(default=252, description="1 year of trading days")
    min_periods: int = Field(default=30, description="Minimum observations required")

    # Clip bounds
    clip_lower: float = Field(default=-3.0)
    clip_upper: float = Field(default=3.0)

    def calculate_zscore(
        self,
        value: float,
        indicator: str,
        historical: Optional[List[float]] = None
    ) -> float:
        """Calculate z-score using configured method.

        Args:
            value: Current value to normalize
            indicator: Indicator name (e.g., 'dxy', 'vix', 'embi')
            historical: Historical values for rolling calculation

        Returns:
            Z-score clipped to configured bounds
        """
        if self.method == ZScoreMethod.STATIC:
            params = self.static_params.get(indicator, {"mean": 0, "std": 1})
            z = (value - params["mean"]) / params["std"]
        elif self.method == ZScoreMethod.ROLLING and historical is not None and len(historical) >= self.min_periods:
            import numpy as np
            window = historical[-self.rolling_window_days:] if len(historical) > self.rolling_window_days else historical
            z = (value - np.mean(window)) / np.std(window)
        else:
            z = 0.0

        return float(np.clip(z, self.clip_lower, self.clip_upper))


# Default z-score configuration (static method for consistency)
DEFAULT_ZSCORE_CONFIG = ZScoreConfig()


# =============================================================================
# STALENESS VALIDATION CONTRACTS
# =============================================================================


class StalenessThresholds(BaseModel):
    """Thresholds for data staleness warnings and errors.

    Contract: CTR-L1-STALE-001
    """
    model_config = ConfigDict(frozen=True)

    # OHLCV staleness (minutes)
    ohlcv_warning_minutes: int = Field(default=10, description="Warn if OHLCV older than this")
    ohlcv_error_minutes: int = Field(default=30, description="Error if OHLCV older than this")

    # Macro staleness (days) by schedule
    daily_warning_days: int = Field(default=3)
    daily_error_days: int = Field(default=7)
    monthly_warning_days: int = Field(default=35)
    monthly_error_days: int = Field(default=60)


class StalenessCheckResult(BaseModel):
    """Result of staleness validation.

    Contract: CTR-L1-STALE-002
    """
    check_time: dt.datetime = Field(default_factory=dt.datetime.utcnow)
    thresholds: StalenessThresholds = Field(default_factory=StalenessThresholds)

    # OHLCV status
    ohlcv_latest_time: Optional[dt.datetime] = Field(default=None)
    ohlcv_age_minutes: Optional[float] = Field(default=None)
    ohlcv_status: Literal["fresh", "warning", "error", "missing"] = Field(default="missing")

    # Macro staleness (per column)
    macro_staleness: Dict[str, Dict[str, Any]] = Field(
        default_factory=dict,
        description="column -> {latest_date, age_days, status}"
    )

    # Summary
    stale_columns: List[str] = Field(default_factory=list)
    is_inference_ready: bool = Field(default=False)
    blocking_issues: List[str] = Field(default_factory=list)

    def add_ohlcv_check(self, latest_time: Optional[dt.datetime]) -> None:
        """Update OHLCV staleness status."""
        if latest_time is None:
            self.ohlcv_status = "missing"
            self.blocking_issues.append("OHLCV data missing")
            return

        self.ohlcv_latest_time = latest_time
        age_minutes = (self.check_time - latest_time).total_seconds() / 60
        self.ohlcv_age_minutes = age_minutes

        if age_minutes < self.thresholds.ohlcv_warning_minutes:
            self.ohlcv_status = "fresh"
        elif age_minutes < self.thresholds.ohlcv_error_minutes:
            self.ohlcv_status = "warning"
        else:
            self.ohlcv_status = "error"
            self.blocking_issues.append(f"OHLCV stale: {age_minutes:.0f} minutes old")

    def finalize(self) -> "StalenessCheckResult":
        """Compute final inference readiness."""
        self.is_inference_ready = (
            len(self.blocking_issues) == 0 and
            self.ohlcv_status in ["fresh", "warning"]
        )
        return self


# Default staleness thresholds
DEFAULT_STALENESS_THRESHOLDS = StalenessThresholds()


# =============================================================================
# OUTPUT CONTRACTS
# =============================================================================


class CalculatedFeatures(BaseModel):
    """Single row of calculated features.

    Contract: CTR-L1-OUTPUT-001
    Target: inference_features_5m table
    """
    time: dt.datetime = Field(..., description="Feature timestamp")

    # Returns
    log_ret_5m: Optional[float] = Field(default=None)
    log_ret_1h: Optional[float] = Field(default=None)
    log_ret_4h: Optional[float] = Field(default=None)

    # Technical
    rsi_9: Optional[float] = Field(default=None, ge=0, le=100)
    atr_pct: Optional[float] = Field(default=None, ge=0)
    adx_14: Optional[float] = Field(default=None, ge=0, le=100)

    # Macro Z-scores
    dxy_z: Optional[float] = Field(default=None)
    vix_z: Optional[float] = Field(default=None)
    embi_z: Optional[float] = Field(default=None)

    # Macro changes
    dxy_change_1d: Optional[float] = Field(default=None)
    brent_change_1d: Optional[float] = Field(default=None)

    # Derived
    rate_spread: Optional[float] = Field(default=None)
    usdmxn_change_1d: Optional[float] = Field(default=None)

    @property
    def non_null_count(self) -> int:
        """Count of non-null features."""
        features = [
            self.log_ret_5m, self.log_ret_1h, self.log_ret_4h,
            self.rsi_9, self.atr_pct, self.adx_14,
            self.dxy_z, self.vix_z, self.embi_z,
            self.dxy_change_1d, self.brent_change_1d,
            self.rate_spread, self.usdmxn_change_1d
        ]
        return sum(1 for f in features if f is not None)

    @property
    def completeness_ratio(self) -> float:
        """Ratio of non-null features."""
        return self.non_null_count / 13

    def to_observation_array(self) -> List[float]:
        """Convert to observation array (without state features).

        Returns 13 core features in canonical order.
        """
        return [
            self.log_ret_5m or 0.0,
            self.log_ret_1h or 0.0,
            self.log_ret_4h or 0.0,
            self.rsi_9 or 50.0,  # Default to neutral RSI
            self.atr_pct or 0.0,
            self.adx_14 or 0.0,
            self.dxy_z or 0.0,
            self.dxy_change_1d or 0.0,
            self.vix_z or 0.0,
            self.embi_z or 0.0,
            self.brent_change_1d or 0.0,
            self.rate_spread or 0.0,
            self.usdmxn_change_1d or 0.0,
        ]


class FeatureCalculationResult(BaseModel):
    """Result of feature calculation task.

    Contract: CTR-L1-TASK-001
    """
    status: FeatureCalculationStatus
    rows_inserted: int = Field(default=0, ge=0)
    ohlcv_bars_used: int = Field(default=0, ge=0)
    macro_records_used: int = Field(default=0, ge=0)
    latest_feature_time: Optional[dt.datetime] = Field(default=None)
    reason: Optional[str] = Field(default=None)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    @property
    def is_successful(self) -> bool:
        return self.status == FeatureCalculationStatus.SUCCESS


class FeatureValidationResult(BaseModel):
    """Result of feature validation task.

    Contract: CTR-L1-TASK-002
    """
    status: Literal["valid", "incomplete", "stale"] = Field(default="valid")
    latest_ohlcv_time: Optional[dt.datetime] = Field(default=None)
    latest_feature_time: Optional[dt.datetime] = Field(default=None)
    recent_feature_count: int = Field(default=0, ge=0)
    feature_completeness: int = Field(
        default=0,
        ge=0,
        le=13,
        description="Number of non-null features in latest row"
    )
    invalid_dates: List[Dict[str, str]] = Field(default_factory=list)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    @property
    def is_valid(self) -> bool:
        return self.status == "valid" and self.feature_completeness >= 4


# =============================================================================
# SENSOR CONTRACTS
# =============================================================================


class NewBarDetection(BaseModel):
    """Result of new bar detection sensor.

    Contract: CTR-L1-SENSOR-001
    """
    detected: bool = Field(default=False)
    bar_time: Optional[dt.datetime] = Field(default=None)
    bar_age_seconds: Optional[float] = Field(default=None)
    is_fresh: bool = Field(default=False, description="Bar is < max_staleness")

    @model_validator(mode="after")
    def validate_detection(self) -> "NewBarDetection":
        """Set is_fresh based on bar age."""
        if self.detected and self.bar_age_seconds is not None:
            # Default max staleness is 10 minutes
            self.is_fresh = self.bar_age_seconds < 600
        return self


# =============================================================================
# QUALITY CONTRACTS
# =============================================================================


class L1QualityReport(BaseModel):
    """L1 feature quality report.

    Contract: CTR-L1-REPORT-001
    """
    report_time: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    # Feature stats
    latest_feature_time: Optional[dt.datetime] = Field(default=None)
    features_in_last_hour: int = Field(default=0, ge=0)
    average_completeness: float = Field(default=0.0, ge=0.0, le=1.0)

    # Data quality
    ohlcv_macro_lag_minutes: Optional[float] = Field(
        default=None,
        description="Time difference between latest OHLCV and macro data"
    )
    null_feature_counts: Dict[str, int] = Field(
        default_factory=dict,
        description="Count of null values per feature in recent data"
    )

    # Health
    is_healthy: bool = Field(default=False)
    issues: List[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_health(self) -> "L1QualityReport":
        """Determine if L1 is healthy."""
        issues = []

        if self.features_in_last_hour == 0:
            issues.append("No features calculated in last hour")

        if self.average_completeness < 0.5:
            issues.append(f"Low feature completeness: {self.average_completeness:.1%}")

        if self.ohlcv_macro_lag_minutes and self.ohlcv_macro_lag_minutes > 60:
            issues.append(f"OHLCV-macro lag: {self.ohlcv_macro_lag_minutes:.0f} minutes")

        self.issues = issues
        self.is_healthy = len(issues) == 0
        return self


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================


def create_feature_calculation_result(
    rows_inserted: int,
    ohlcv_bars: int,
    macro_records: int,
    latest_time: Optional[dt.datetime] = None,
    reason: Optional[str] = None
) -> FeatureCalculationResult:
    """Factory for feature calculation result."""
    if rows_inserted > 0:
        status = FeatureCalculationStatus.SUCCESS
    elif ohlcv_bars < FEATURE_CONTRACT.min_warmup_bars:
        status = FeatureCalculationStatus.INSUFFICIENT_DATA
    else:
        status = FeatureCalculationStatus.WARNING

    return FeatureCalculationResult(
        status=status,
        rows_inserted=rows_inserted,
        ohlcv_bars_used=ohlcv_bars,
        macro_records_used=macro_records,
        latest_feature_time=latest_time,
        reason=reason
    )


def create_calculated_features_from_dict(
    time: dt.datetime,
    features: Dict[str, Any]
) -> CalculatedFeatures:
    """Factory to create CalculatedFeatures from dictionary."""
    return CalculatedFeatures(
        time=time,
        log_ret_5m=features.get("log_ret_5m"),
        log_ret_1h=features.get("log_ret_1h"),
        log_ret_4h=features.get("log_ret_4h"),
        rsi_9=features.get("rsi_9"),
        atr_pct=features.get("atr_pct"),
        adx_14=features.get("adx_14"),
        dxy_z=features.get("dxy_z"),
        vix_z=features.get("vix_z"),
        embi_z=features.get("embi_z"),
        dxy_change_1d=features.get("dxy_change_1d"),
        brent_change_1d=features.get("brent_change_1d"),
        rate_spread=features.get("rate_spread"),
        usdmxn_change_1d=features.get("usdmxn_change_1d"),
    )
