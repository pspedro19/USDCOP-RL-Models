"""
L5 Inference Pipeline Contracts
================================

Pydantic contracts for Layer 5 (Inference) data flows.
Ensures type safety and validation for realtime inference operations.

Contract: CTR-L5-001

Architecture:
    L1 (Features) → L5 (Inference) → trading.model_inferences + dw.fact_strategy_signals

Data Flow:
    inference_features_5m → ObservationBuilder → Model → Signal → Database/Redis

Observation Space:
    - 13 core market features (from L1)
    - 2 state features (position, time_normalized)
    - Total: 15 dimensions

Version: 1.0.0
Author: Generated by Contract System
"""

from __future__ import annotations

import datetime as dt
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Tuple, Union

import numpy as np
from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    field_validator,
    model_validator,
)


# =============================================================================
# ENUMS
# =============================================================================


class L5XComKeys(str, Enum):
    """XCom keys for L5 inter-task communication.

    Contract: CTR-L5-XCOM-001
    """
    # System readiness
    SYSTEM_STATUS = "system_status"
    CAN_INFER = "can_infer"
    DATA_AGE_MINUTES = "data_age_minutes"

    # Models
    LOADED_MODELS = "loaded_models"
    FAILED_MODELS = "failed_models"

    # Observation
    MARKET_FEATURES = "market_features"
    SIGNAL_BAR_PRICE = "signal_bar_price"
    EXECUTION_PRICE = "execution_price"
    BAR_NUMBER = "bar_number"

    # Inference
    INFERENCE_RESULTS = "inference_results"

    # Sensor
    DETECTED_FEATURE_TIME = "detected_feature_time"
    LAST_PROCESSED_FEATURE_TIME = "last_processed_feature_time"


class SignalAction(str, Enum):
    """Trading signal actions.

    Contract: CTR-L5-SIGNAL-001
    """
    LONG = "LONG"
    SHORT = "SHORT"
    HOLD = "HOLD"
    CLOSE = "CLOSE"


class SystemStatus(str, Enum):
    """System readiness status."""
    READY = "READY"
    SKIP = "SKIP"
    STALE = "STALE"
    ERROR = "ERROR"


class ModelType(str, Enum):
    """Supported RL model types."""
    PPO = "PPO"
    SAC = "SAC"
    TD3 = "TD3"
    A2C = "A2C"
    DQN = "DQN"


class TradeStatus(str, Enum):
    """Trade execution status."""
    PENDING = "pending"
    EXECUTED = "executed"
    REJECTED = "rejected"
    CLOSED = "closed"


# =============================================================================
# OBSERVATION CONTRACTS
# =============================================================================


class ObservationContract(BaseModel):
    """Observation space contract.

    Contract: CTR-L5-OBS-001
    Total dimension: 15 (13 market + 2 state)
    """
    model_config = ConfigDict(frozen=True)

    version: str = Field(default="current")
    total_dim: int = Field(default=15)
    market_feature_dim: int = Field(default=13)
    state_feature_dim: int = Field(default=2)

    feature_order: Tuple[str, ...] = Field(
        default=(
            # 13 Market features (from L1)
            "log_ret_5m", "log_ret_1h", "log_ret_4h",
            "rsi_9", "atr_pct", "adx_14",
            "dxy_z", "dxy_change_1d", "vix_z", "embi_z",
            "brent_change_1d", "rate_spread", "usdmxn_change_1d",
            # 2 State features (runtime)
            "position", "time_normalized"
        )
    )

    clip_min: float = Field(default=-5.0)
    clip_max: float = Field(default=5.0)

    def validate_observation(self, obs: List[float]) -> bool:
        """Validate observation array."""
        if len(obs) != self.total_dim:
            return False
        return all(self.clip_min <= v <= self.clip_max or np.isnan(v) for v in obs)


# Singleton instance
OBSERVATION_CONTRACT = ObservationContract()


class MarketFeatures(BaseModel):
    """Market features from L1 for observation building.

    Contract: CTR-L5-INPUT-001
    """
    # Returns
    log_ret_5m: float = Field(default=0.0)
    log_ret_1h: float = Field(default=0.0)
    log_ret_4h: float = Field(default=0.0)

    # Technical
    rsi_9: float = Field(default=50.0, ge=0, le=100)
    atr_pct: float = Field(default=0.0, ge=0)
    adx_14: float = Field(default=0.0, ge=0, le=100)

    # Macro Z-scores
    dxy_z: float = Field(default=0.0)
    dxy_change_1d: float = Field(default=0.0)
    vix_z: float = Field(default=0.0)
    embi_z: float = Field(default=0.0)

    # Changes
    brent_change_1d: float = Field(default=0.0)
    rate_spread: float = Field(default=0.0)
    usdmxn_change_1d: float = Field(default=0.0)

    def to_array(self) -> List[float]:
        """Convert to array in canonical order."""
        return [
            self.log_ret_5m, self.log_ret_1h, self.log_ret_4h,
            self.rsi_9, self.atr_pct, self.adx_14,
            self.dxy_z, self.dxy_change_1d, self.vix_z, self.embi_z,
            self.brent_change_1d, self.rate_spread, self.usdmxn_change_1d
        ]


class StateFeatures(BaseModel):
    """State features for observation building.

    Contract: CTR-L5-INPUT-002
    """
    position: float = Field(
        default=0.0,
        ge=-1.0,
        le=1.0,
        description="Current position: -1 (short), 0 (flat), 1 (long)"
    )
    time_normalized: float = Field(
        default=0.0,
        ge=0.0,
        le=1.0,
        description="Normalized time in session (0=start, 1=end)"
    )

    def to_array(self) -> List[float]:
        """Convert to array."""
        return [self.position, self.time_normalized]


class FullObservation(BaseModel):
    """Full 15-dim observation for inference.

    Contract: CTR-L5-INPUT-003
    """
    market_features: MarketFeatures
    state_features: StateFeatures
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    def to_numpy(self) -> np.ndarray:
        """Convert to numpy array for model inference."""
        market = self.market_features.to_array()
        state = self.state_features.to_array()
        return np.array(market + state, dtype=np.float32)

    @property
    def observation_hash(self) -> str:
        """Generate hash for observation deduplication."""
        import hashlib
        obs = self.to_numpy()
        return hashlib.md5(obs.tobytes()).hexdigest()[:12]


# =============================================================================
# MODEL CONTRACTS
# =============================================================================


class ModelConfig(BaseModel):
    """Configuration for a single inference model.

    Contract: CTR-L5-MODEL-001
    Source: config.models table
    """
    model_id: str = Field(..., min_length=1)
    model_name: str = Field(...)
    model_type: ModelType
    model_path: str = Field(...)
    version: str = Field(default="v1.0.0")
    enabled: bool = Field(default=True)
    is_production: bool = Field(default=False)
    priority: int = Field(default=100, ge=1)

    # Thresholds (wider HOLD zone)
    threshold_long: float = Field(default=0.33)
    threshold_short: float = Field(default=-0.33)


class ModelLoadResult(BaseModel):
    """Result of model loading.

    Contract: CTR-L5-MODEL-002
    """
    model_id: str
    model_name: str
    model_type: ModelType
    is_production: bool
    loaded_successfully: bool = Field(default=True)
    error: Optional[str] = Field(default=None)
    load_time_ms: Optional[float] = Field(default=None)


# =============================================================================
# INFERENCE CONTRACTS
# =============================================================================


class InferenceResult(BaseModel):
    """Result of a single model inference.

    Contract: CTR-L5-OUTPUT-001
    """
    model_id: str
    model_name: str
    model_type: str
    raw_action: float = Field(..., description="Raw continuous action from model")
    signal: SignalAction
    confidence: float = Field(default=0.0, ge=0.0, le=1.0)
    latency_ms: float = Field(default=0.0, ge=0.0)
    observation_hash: str = Field(default="", max_length=20)
    bar_number: int = Field(default=1, ge=1, le=60)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    # State at inference time
    state_features: List[float] = Field(
        default_factory=list,
        description="[position, time_normalized]"
    )

    # Risk validation
    allowed: bool = Field(default=True)
    rejection_reason: Optional[str] = Field(default=None)

    # Error handling
    error: Optional[str] = Field(default=None)

    @property
    def is_successful(self) -> bool:
        return self.error is None

    @property
    def is_trade_signal(self) -> bool:
        return self.signal in (SignalAction.LONG, SignalAction.SHORT)


class BatchInferenceResult(BaseModel):
    """Result of inference across all models.

    Contract: CTR-L5-OUTPUT-002
    """
    results: List[InferenceResult] = Field(default_factory=list)
    total_models: int = Field(default=0, ge=0)
    successful_count: int = Field(default=0, ge=0)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    @property
    def signal_distribution(self) -> Dict[str, int]:
        """Count signals by type."""
        dist = {"LONG": 0, "SHORT": 0, "HOLD": 0, "CLOSE": 0}
        for r in self.results:
            if r.is_successful:
                dist[r.signal.value] = dist.get(r.signal.value, 0) + 1
        return dist

    @property
    def consensus_signal(self) -> Optional[SignalAction]:
        """Get majority signal if exists."""
        dist = self.signal_distribution
        max_count = max(dist.values()) if dist else 0
        if max_count > len(self.results) / 2:
            for signal, count in dist.items():
                if count == max_count:
                    return SignalAction(signal)
        return None


# =============================================================================
# TRADE CONTRACTS
# =============================================================================


class TradeSignal(BaseModel):
    """Trade signal for execution.

    Contract: CTR-L5-TRADE-001
    """
    model_id: str
    signal: SignalAction
    confidence: float = Field(ge=0.0, le=1.0)
    entry_price: Decimal = Field(..., gt=0)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    # Risk parameters (optional)
    stop_loss: Optional[Decimal] = Field(default=None, gt=0)
    take_profit: Optional[Decimal] = Field(default=None, gt=0)
    position_size: float = Field(default=1.0, gt=0, le=1.0)

    @property
    def side(self) -> str:
        """Get trade side for database."""
        if self.signal == SignalAction.LONG:
            return "buy"
        elif self.signal == SignalAction.SHORT:
            return "sell"
        return "hold"


class ExecutedTrade(BaseModel):
    """Executed trade record.

    Contract: CTR-L5-TRADE-002
    Target: trading.model_inferences + dw.fact_strategy_signals
    """
    trade_id: str = Field(default="")
    model_id: str
    signal: SignalAction
    side: Literal["buy", "sell", "hold"]
    entry_price: Decimal
    exit_price: Optional[Decimal] = Field(default=None)
    pnl: Optional[float] = Field(default=None)
    pnl_pct: Optional[float] = Field(default=None)
    status: TradeStatus = Field(default=TradeStatus.EXECUTED)
    entry_time: dt.datetime
    exit_time: Optional[dt.datetime] = Field(default=None)

    @property
    def is_closed(self) -> bool:
        return self.status == TradeStatus.CLOSED

    @property
    def duration_minutes(self) -> Optional[float]:
        if self.exit_time and self.entry_time:
            return (self.exit_time - self.entry_time).total_seconds() / 60
        return None


# =============================================================================
# RISK CONTRACTS
# =============================================================================


class RiskLimits(BaseModel):
    """Risk management limits.

    Contract: CTR-L5-RISK-001
    """
    max_drawdown_pct: float = Field(default=15.0, ge=0, le=100)
    max_daily_loss_pct: float = Field(default=5.0, ge=0, le=100)
    max_trades_per_day: int = Field(default=20, ge=1)
    max_position_size: float = Field(default=1.0, gt=0, le=1.0)
    min_confidence: float = Field(default=0.0, ge=0, le=1.0)


class RiskValidationResult(BaseModel):
    """Result of risk validation.

    Contract: CTR-L5-RISK-002
    """
    allowed: bool = Field(default=True)
    reason: Optional[str] = Field(default=None)
    current_drawdown_pct: float = Field(default=0.0, ge=0)
    daily_loss_pct: float = Field(default=0.0)
    trades_today: int = Field(default=0, ge=0)


# =============================================================================
# MONITORING CONTRACTS
# =============================================================================


class ModelHealth(BaseModel):
    """Model health metrics.

    Contract: CTR-L5-MONITOR-001
    """
    model_id: str
    action_mean: float = Field(default=0.0)
    action_std: float = Field(default=1.0)
    recent_pnl_mean: Optional[float] = Field(default=None)
    drift_detected: bool = Field(default=False)
    last_inference_time: Optional[dt.datetime] = Field(default=None)
    inference_count_today: int = Field(default=0, ge=0)


class L5HealthReport(BaseModel):
    """L5 system health report.

    Contract: CTR-L5-MONITOR-002
    """
    report_time: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    # System status
    system_status: SystemStatus = Field(default=SystemStatus.READY)
    models_loaded: int = Field(default=0, ge=0)
    models_failed: int = Field(default=0, ge=0)

    # Recent activity
    inferences_last_hour: int = Field(default=0, ge=0)
    trades_today: int = Field(default=0, ge=0)
    signals_distribution: Dict[str, int] = Field(default_factory=dict)

    # Latency
    avg_inference_latency_ms: float = Field(default=0.0, ge=0)
    p99_inference_latency_ms: float = Field(default=0.0, ge=0)

    # Data freshness
    feature_staleness_minutes: Optional[float] = Field(default=None)
    ohlcv_staleness_minutes: Optional[float] = Field(default=None)

    # Health
    is_healthy: bool = Field(default=False)
    issues: List[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_health(self) -> "L5HealthReport":
        """Determine if L5 is healthy."""
        issues = []

        if self.system_status != SystemStatus.READY:
            issues.append(f"System status: {self.system_status.value}")

        if self.models_loaded == 0:
            issues.append("No models loaded")

        if self.feature_staleness_minutes and self.feature_staleness_minutes > 10:
            issues.append(f"Stale features: {self.feature_staleness_minutes:.0f} min")

        if self.avg_inference_latency_ms > 100:
            issues.append(f"High latency: {self.avg_inference_latency_ms:.0f}ms")

        self.issues = issues
        self.is_healthy = len(issues) == 0
        return self


# =============================================================================
# TASK RESULT CONTRACTS
# =============================================================================


class SystemReadinessResult(BaseModel):
    """Result of system readiness check.

    Contract: CTR-L5-TASK-001
    """
    status: SystemStatus
    can_infer: bool = Field(default=False)
    reason: str = Field(default="")
    observation_dim: int = Field(default=15)
    data_age_minutes: Optional[float] = Field(default=None)


class ModelLoadSummary(BaseModel):
    """Summary of model loading task.

    Contract: CTR-L5-TASK-002
    """
    loaded_count: int = Field(default=0, ge=0)
    failed_count: int = Field(default=0, ge=0)
    loaded_models: List[ModelLoadResult] = Field(default_factory=list)


class ObservationBuildResult(BaseModel):
    """Result of observation building task.

    Contract: CTR-L5-TASK-003
    """
    status: Literal["success", "error"]
    bar_number: int = Field(ge=1, le=60)
    signal_price: float = Field(gt=0, description="Price from signal bar (closed)")
    execution_price: float = Field(gt=0, description="Price for trade execution (open)")
    observation_dim: int = Field(default=15)
    error: Optional[str] = Field(default=None)


class InferenceSummary(BaseModel):
    """Summary of inference task.

    Contract: CTR-L5-TASK-004
    """
    total_models: int = Field(default=0, ge=0)
    signal_distribution: Dict[str, int] = Field(default_factory=dict)
    observation_dim: int = Field(default=15)
    timestamp: dt.datetime = Field(default_factory=dt.datetime.utcnow)


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================


def create_inference_result(
    model_id: str,
    model_name: str,
    model_type: str,
    raw_action: float,
    threshold_long: float = 0.33,  # wider HOLD zone
    threshold_short: float = -0.33,  # wider HOLD zone
    bar_number: int = 1,
    latency_ms: float = 0.0,
    observation_hash: str = "",
    state_features: Optional[List[float]] = None
) -> InferenceResult:
    """Factory for inference result with signal discretization."""
    # Discretize action to signal
    if raw_action > threshold_long:
        signal = SignalAction.LONG
    elif raw_action < threshold_short:
        signal = SignalAction.SHORT
    else:
        signal = SignalAction.HOLD

    confidence = min(abs(raw_action), 1.0)

    return InferenceResult(
        model_id=model_id,
        model_name=model_name,
        model_type=model_type,
        raw_action=raw_action,
        signal=signal,
        confidence=confidence,
        latency_ms=latency_ms,
        observation_hash=observation_hash,
        bar_number=bar_number,
        state_features=state_features or [0.0, 0.0]
    )


def create_full_observation(
    market_dict: Dict[str, float],
    position: float = 0.0,
    time_normalized: float = 0.0
) -> FullObservation:
    """Factory for full observation from dictionary."""
    market = MarketFeatures(
        log_ret_5m=market_dict.get("log_ret_5m", 0.0),
        log_ret_1h=market_dict.get("log_ret_1h", 0.0),
        log_ret_4h=market_dict.get("log_ret_4h", 0.0),
        rsi_9=market_dict.get("rsi_9", 50.0),
        atr_pct=market_dict.get("atr_pct", 0.0),
        adx_14=market_dict.get("adx_14", 0.0),
        dxy_z=market_dict.get("dxy_z", 0.0),
        dxy_change_1d=market_dict.get("dxy_change_1d", 0.0),
        vix_z=market_dict.get("vix_z", 0.0),
        embi_z=market_dict.get("embi_z", 0.0),
        brent_change_1d=market_dict.get("brent_change_1d", 0.0),
        rate_spread=market_dict.get("rate_spread", 0.0),
        usdmxn_change_1d=market_dict.get("usdmxn_change_1d", 0.0),
    )

    state = StateFeatures(
        position=position,
        time_normalized=time_normalized
    )

    return FullObservation(
        market_features=market,
        state_features=state
    )
