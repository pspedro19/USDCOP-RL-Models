"""
L3 Model Training Pipeline Contracts
=====================================

Pydantic contracts for Layer 3 (Model Training) data flows.
Ensures type safety and validation for training pipeline operations.

Contract: CTR-L3-001

Architecture:
    L2 (Preprocessing) → L3 (Training) → Model Registry → L5 (Inference)

Data Flow:
    RL Datasets → Validation → Norm Stats → Contract → Training → Registration

Pipeline Stages:
    1. validate_dataset: Validate dataset exists and has required columns
    2. generate_norm_stats: Calculate normalization statistics
    3. create_contract: Create feature contract for model
    4. train_model: Train PPO model with environment
    5. register_model: Register in DB and MLflow
    6. backtest_validation: Optional validation backtest
    7. pipeline_summary: Generate summary report

Version: 1.0.0
Author: Generated by Contract System
"""

from __future__ import annotations

import datetime as dt
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Tuple, Union

from pydantic import (
    BaseModel,
    ConfigDict,
    Field,
    field_validator,
    model_validator,
)


# =============================================================================
# ENUMS
# =============================================================================


class L3XComKeys(str, Enum):
    """XCom keys for L3 inter-task communication.

    Contract: CTR-L3-XCOM-001
    """
    # Dataset validation
    DATASET_PATH = "dataset_path"
    DATASET_HASH = "dataset_hash"
    DATASET_INFO = "dataset_info"

    # Normalization
    NORM_STATS_PATH = "norm_stats_path"
    NORM_STATS_HASH = "norm_stats_hash"
    NORM_STATS = "norm_stats"

    # Contract
    CONTRACT_PATH = "contract_path"
    CONTRACT_HASH = "contract_hash"
    CONTRACT = "contract"

    # Training
    MODEL_PATH = "model_path"
    MODEL_HASH = "model_hash"
    MLFLOW_RUN_ID = "mlflow_run_id"
    TRAINING_RESULT = "training_result"

    # Registration
    MODEL_ID = "model_id"

    # Backtest
    BACKTEST_RESULT = "backtest_result"


class TrainingStatus(str, Enum):
    """Status of training pipeline task."""
    SUCCESS = "success"
    FAILED = "failed"
    RUNNING = "running"
    SKIPPED = "skipped"
    CANCELLED = "cancelled"


class ModelStatus(str, Enum):
    """Model registration status."""
    REGISTERED = "registered"
    VALIDATED = "validated"
    PRODUCTION = "production"
    DEPRECATED = "deprecated"
    FAILED = "failed"


class DatasetSplit(str, Enum):
    """Dataset split type."""
    TRAIN = "train"
    VALIDATION = "val"
    TEST = "test"


# =============================================================================
# CONFIGURATION CONTRACTS
# =============================================================================


class TrainingConfig(BaseModel):
    """Training configuration.

    Contract: CTR-L3-CONFIG-001
    Source: Airflow Variables or DAG run conf
    """
    version: str = Field(default="current")
    experiment_name: str = Field(default="ppo_usdcop")

    # Dataset
    dataset_name: str = Field(default="RL_DS3_MACRO_CORE.csv")
    dataset_dir: str = Field(default="5min")

    # Features (13 market + 2 state = 15 observation dim)
    feature_columns: List[str] = Field(
        default=[
            "log_ret_5m", "log_ret_1h", "log_ret_4h",
            "rsi_9", "atr_pct", "adx_14",
            "dxy_z", "dxy_change_1d", "vix_z", "embi_z",
            "brent_change_1d", "rate_spread", "usdmxn_change_1d",
            "position", "time_normalized"
        ]
    )
    state_features: List[str] = Field(default=["position", "time_normalized"])

    # Technical indicators
    rsi_period: int = Field(default=9, ge=1)
    atr_period: int = Field(default=10, ge=1)
    adx_period: int = Field(default=14, ge=1)

    # Trading hours
    trading_hours_start: str = Field(default="13:00")
    trading_hours_end: str = Field(default="17:55")

    # Hyperparameters
    total_timesteps: int = Field(default=500_000, ge=1000)
    learning_rate: float = Field(default=3e-4, gt=0)
    n_steps: int = Field(default=2048, ge=64)
    batch_size: int = Field(default=64, ge=16)
    n_epochs: int = Field(default=10, ge=1)
    gamma: float = Field(default=0.90, ge=0, le=1)  # From config/trading_config.yaml SSOT
    gae_lambda: float = Field(default=0.95, ge=0, le=1)
    clip_range: float = Field(default=0.2, gt=0, le=1)
    ent_coef: float = Field(default=0.01, ge=0)

    # Environment
    initial_capital: float = Field(default=10_000.0, gt=0)
    transaction_cost_bps: float = Field(default=75.0, ge=0)  # 75 bps = realistic USDCOP spread

    # Split ratios
    train_ratio: float = Field(default=0.70, gt=0, lt=1)
    val_ratio: float = Field(default=0.15, gt=0, lt=1)

    # Options
    auto_register: bool = Field(default=True)
    run_backtest_validation: bool = Field(default=False)
    backtest_start_date: Optional[str] = Field(default=None)
    backtest_end_date: Optional[str] = Field(default=None)

    # MLflow
    mlflow_tracking_uri: Optional[str] = Field(default=None)
    mlflow_enabled: bool = Field(default=True)

    @property
    def observation_dim(self) -> int:
        """Total observation dimension."""
        return len(self.feature_columns)

    @property
    def market_feature_count(self) -> int:
        """Number of market features (excluding state)."""
        return len(self.feature_columns) - len(self.state_features)

    @property
    def test_ratio(self) -> float:
        """Test set ratio."""
        return 1.0 - self.train_ratio - self.val_ratio

    @model_validator(mode="after")
    def validate_ratios(self) -> "TrainingConfig":
        """Ensure split ratios sum to 1."""
        total = self.train_ratio + self.val_ratio
        if total >= 1.0:
            raise ValueError(f"train_ratio + val_ratio must be < 1.0, got {total}")
        return self


class PPOHyperparameters(BaseModel):
    """PPO hyperparameters.

    Contract: CTR-L3-CONFIG-002
    """
    learning_rate: float = Field(default=3e-4, gt=0)
    n_steps: int = Field(default=2048, ge=64)
    batch_size: int = Field(default=64, ge=16)
    n_epochs: int = Field(default=10, ge=1)
    gamma: float = Field(default=0.90, ge=0, le=1)  # From config/trading_config.yaml SSOT
    gae_lambda: float = Field(default=0.95, ge=0, le=1)
    clip_range: float = Field(default=0.2, gt=0, le=1)
    ent_coef: float = Field(default=0.01, ge=0)
    vf_coef: float = Field(default=0.5, gt=0)
    max_grad_norm: float = Field(default=0.5, gt=0)


class EnvironmentConfig(BaseModel):
    """Trading environment configuration.

    Contract: CTR-L3-CONFIG-003
    """
    observation_dim: int = Field(default=15, ge=1)
    initial_capital: float = Field(default=10_000.0, gt=0)
    transaction_cost_bps: float = Field(default=75.0, ge=0)  # 75 bps = realistic USDCOP spread
    random_episode_start: bool = Field(default=True)
    max_episode_steps: int = Field(default=2000, ge=100)
    reward_scaling: float = Field(default=1.0, gt=0)


# =============================================================================
# DATASET CONTRACTS
# =============================================================================


class DatasetInfo(BaseModel):
    """Dataset information from validation.

    Contract: CTR-L3-DATASET-001
    """
    dataset_path: str
    dataset_hash: str
    row_count: int = Field(ge=0)
    column_count: int = Field(ge=0)
    feature_count: int = Field(ge=0)
    date_range: Dict[str, str] = Field(default_factory=dict)

    @property
    def start_date(self) -> Optional[str]:
        return self.date_range.get("start")

    @property
    def end_date(self) -> Optional[str]:
        return self.date_range.get("end")


class DatasetValidationResult(BaseModel):
    """Result of dataset validation task.

    Contract: CTR-L3-TASK-001
    """
    status: TrainingStatus
    dataset_info: Optional[DatasetInfo] = Field(default=None)
    missing_columns: List[str] = Field(default_factory=list)
    error: Optional[str] = Field(default=None)

    @property
    def is_valid(self) -> bool:
        return self.status == TrainingStatus.SUCCESS and len(self.missing_columns) == 0


class DatasetSplitInfo(BaseModel):
    """Information about train/val/test splits.

    Contract: CTR-L3-DATASET-002
    """
    train_size: int = Field(ge=0)
    val_size: int = Field(ge=0)
    test_size: int = Field(ge=0)
    total_size: int = Field(ge=0)
    train_ratio_actual: float = Field(ge=0, le=1)
    val_ratio_actual: float = Field(ge=0, le=1)
    test_ratio_actual: float = Field(ge=0, le=1)


# =============================================================================
# NORMALIZATION CONTRACTS
# =============================================================================


class FeatureNormStats(BaseModel):
    """Normalization statistics for a single feature.

    Contract: CTR-L3-NORM-001
    """
    mean: float
    std: float
    min: float
    max: float

    @property
    def range(self) -> float:
        return self.max - self.min


class NormStatsMetadata(BaseModel):
    """Metadata for normalization statistics.

    Contract: CTR-L3-NORM-002
    """
    version: str
    created_at: dt.datetime
    dataset_hash: str
    feature_count: int
    sample_count: int


class NormalizationStats(BaseModel):
    """Complete normalization statistics.

    Contract: CTR-L3-NORM-003
    """
    features: Dict[str, FeatureNormStats] = Field(default_factory=dict)
    metadata: NormStatsMetadata

    @property
    def feature_names(self) -> List[str]:
        return list(self.features.keys())

    def get_stats(self, feature_name: str) -> Optional[FeatureNormStats]:
        return self.features.get(feature_name)


class NormStatsResult(BaseModel):
    """Result of normalization stats generation.

    Contract: CTR-L3-TASK-002
    """
    status: TrainingStatus
    norm_stats_path: Optional[str] = Field(default=None)
    norm_stats_hash: Optional[str] = Field(default=None)
    feature_count: int = Field(default=0, ge=0)
    error: Optional[str] = Field(default=None)


# =============================================================================
# CONTRACT CONTRACTS
# =============================================================================


class FeatureContract(BaseModel):
    """Feature contract for model.

    Contract: CTR-L3-CONTRACT-001
    """
    version: str
    observation_dim: int = Field(ge=1)
    feature_order: List[str]
    norm_stats_path: str
    model_path: str

    # Technical indicators
    rsi_period: int = Field(ge=1)
    atr_period: int = Field(ge=1)
    adx_period: int = Field(ge=1)
    warmup_bars: int = Field(ge=1)

    # Trading hours
    trading_hours_start: str
    trading_hours_end: str

    # Metadata
    created_at: dt.datetime
    created_from_dataset: str
    dataset_hash: str
    norm_stats_hash: str
    contract_hash: str
    sample_count: int = Field(ge=0)


class ContractResult(BaseModel):
    """Result of contract creation.

    Contract: CTR-L3-TASK-003
    """
    status: TrainingStatus
    contract_path: Optional[str] = Field(default=None)
    contract_hash: Optional[str] = Field(default=None)
    observation_dim: int = Field(default=0, ge=0)
    error: Optional[str] = Field(default=None)


# =============================================================================
# TRAINING CONTRACTS
# =============================================================================


class TrainingMetrics(BaseModel):
    """Training metrics.

    Contract: CTR-L3-METRICS-001
    """
    best_mean_reward: float = Field(default=0.0)
    final_mean_reward: float = Field(default=0.0)
    total_timesteps: int = Field(default=0, ge=0)
    training_duration_seconds: float = Field(default=0.0, ge=0)
    eval_episodes: int = Field(default=0, ge=0)
    policy_loss: Optional[float] = Field(default=None)
    value_loss: Optional[float] = Field(default=None)
    entropy_loss: Optional[float] = Field(default=None)


class TrainingResult(BaseModel):
    """Result of model training task.

    Contract: CTR-L3-TASK-004
    """
    status: TrainingStatus
    model_path: Optional[str] = Field(default=None)
    model_hash: Optional[str] = Field(default=None)
    mlflow_run_id: Optional[str] = Field(default=None)
    metrics: TrainingMetrics = Field(default_factory=TrainingMetrics)
    error: Optional[str] = Field(default=None)

    @property
    def is_successful(self) -> bool:
        return self.status == TrainingStatus.SUCCESS and self.model_path is not None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for XCom."""
        return {
            "status": self.status.value,
            "model_path": self.model_path,
            "model_hash": self.model_hash,
            "mlflow_run_id": self.mlflow_run_id,
            "training_duration_seconds": self.metrics.training_duration_seconds,
            "best_mean_reward": self.metrics.best_mean_reward,
            "final_mean_reward": self.metrics.final_mean_reward,
            "total_timesteps": self.metrics.total_timesteps,
        }


# =============================================================================
# REGISTRATION CONTRACTS
# =============================================================================


class ModelRegistration(BaseModel):
    """Model registration record.

    Contract: CTR-L3-REG-001
    Target: model_registry table
    """
    model_id: str
    model_version: str
    model_path: str
    model_hash: str
    norm_stats_hash: str
    config_hash: str
    observation_dim: int = Field(ge=1)
    action_space: int = Field(default=3)  # LONG, SHORT, HOLD
    feature_order: List[str]
    validation_metrics: Dict[str, Any] = Field(default_factory=dict)
    status: ModelStatus = Field(default=ModelStatus.REGISTERED)
    created_at: dt.datetime = Field(default_factory=dt.datetime.utcnow)


class RegistrationResult(BaseModel):
    """Result of model registration.

    Contract: CTR-L3-TASK-005
    """
    status: TrainingStatus
    model_id: Optional[str] = Field(default=None)
    db_id: Optional[int] = Field(default=None)
    mlflow_version: Optional[str] = Field(default=None)
    skipped: bool = Field(default=False)
    error: Optional[str] = Field(default=None)


# =============================================================================
# BACKTEST CONTRACTS
# =============================================================================


class BacktestConfig(BaseModel):
    """Backtest configuration.

    Contract: CTR-L3-BT-001
    """
    start_date: str
    end_date: str
    model_id: str
    initial_capital: float = Field(default=10_000.0, gt=0)
    transaction_cost_bps: float = Field(default=75.0, ge=0)  # 75 bps = realistic USDCOP spread


class BacktestMetrics(BaseModel):
    """Backtest performance metrics.

    Contract: CTR-L3-BT-002
    """
    total_return_pct: float = Field(default=0.0)
    sharpe_ratio: Optional[float] = Field(default=None)
    sortino_ratio: Optional[float] = Field(default=None)
    max_drawdown_pct: float = Field(default=0.0)
    win_rate: float = Field(default=0.0, ge=0, le=1)
    profit_factor: Optional[float] = Field(default=None)
    total_trades: int = Field(default=0, ge=0)
    avg_trade_duration_minutes: Optional[float] = Field(default=None)


class BacktestResult(BaseModel):
    """Result of backtest validation.

    Contract: CTR-L3-TASK-006
    """
    status: TrainingStatus
    config: Optional[BacktestConfig] = Field(default=None)
    metrics: BacktestMetrics = Field(default_factory=BacktestMetrics)
    passed_validation: bool = Field(default=False)
    validation_criteria: Dict[str, bool] = Field(default_factory=dict)
    error: Optional[str] = Field(default=None)


# =============================================================================
# PIPELINE SUMMARY CONTRACTS
# =============================================================================


class PipelineSummary(BaseModel):
    """Pipeline execution summary.

    Contract: CTR-L3-SUMMARY-001
    """
    status: TrainingStatus
    version: str
    model_id: Optional[str] = Field(default=None)
    model_path: Optional[str] = Field(default=None)
    norm_stats_path: Optional[str] = Field(default=None)
    contract_path: Optional[str] = Field(default=None)

    # Dataset info
    dataset_rows: int = Field(default=0, ge=0)

    # Training info
    training_duration_seconds: float = Field(default=0.0, ge=0)
    best_mean_reward: float = Field(default=0.0)
    total_timesteps: int = Field(default=0, ge=0)

    # Backtest info (optional)
    backtest_sharpe: Optional[float] = Field(default=None)
    backtest_max_drawdown: Optional[float] = Field(default=None)

    # Timestamps
    started_at: dt.datetime = Field(default_factory=dt.datetime.utcnow)
    completed_at: Optional[dt.datetime] = Field(default=None)

    @property
    def duration_minutes(self) -> Optional[float]:
        if self.completed_at:
            return (self.completed_at - self.started_at).total_seconds() / 60
        return None


# =============================================================================
# QUALITY CONTRACTS
# =============================================================================


class L3QualityReport(BaseModel):
    """L3 training quality report.

    Contract: CTR-L3-REPORT-001
    """
    report_time: dt.datetime = Field(default_factory=dt.datetime.utcnow)

    # Pipeline status
    pipeline_status: TrainingStatus = Field(default=TrainingStatus.SUCCESS)
    stages_completed: int = Field(default=0, ge=0)
    stages_total: int = Field(default=7, ge=1)

    # Model quality
    model_id: Optional[str] = Field(default=None)
    best_mean_reward: float = Field(default=0.0)
    training_converged: bool = Field(default=False)

    # Validation
    backtest_passed: Optional[bool] = Field(default=None)

    # Issues
    is_healthy: bool = Field(default=False)
    issues: List[str] = Field(default_factory=list)

    @model_validator(mode="after")
    def validate_health(self) -> "L3QualityReport":
        """Determine if training was healthy."""
        issues = []

        if self.pipeline_status != TrainingStatus.SUCCESS:
            issues.append(f"Pipeline status: {self.pipeline_status.value}")

        if self.stages_completed < self.stages_total:
            issues.append(f"Only {self.stages_completed}/{self.stages_total} stages completed")

        if self.best_mean_reward < 0:
            issues.append(f"Negative mean reward: {self.best_mean_reward:.2f}")

        if self.backtest_passed is False:
            issues.append("Backtest validation failed")

        self.issues = issues
        self.is_healthy = len(issues) == 0
        return self


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================


def create_training_result(
    model_path: Optional[str] = None,
    model_hash: Optional[str] = None,
    mlflow_run_id: Optional[str] = None,
    best_reward: float = 0.0,
    final_reward: float = 0.0,
    timesteps: int = 0,
    duration_seconds: float = 0.0,
    error: Optional[str] = None
) -> TrainingResult:
    """Factory for training result."""
    status = TrainingStatus.SUCCESS if model_path and not error else TrainingStatus.FAILED

    return TrainingResult(
        status=status,
        model_path=model_path,
        model_hash=model_hash,
        mlflow_run_id=mlflow_run_id,
        metrics=TrainingMetrics(
            best_mean_reward=best_reward,
            final_mean_reward=final_reward,
            total_timesteps=timesteps,
            training_duration_seconds=duration_seconds,
        ),
        error=error
    )


def create_pipeline_summary(
    config: TrainingConfig,
    dataset_info: Optional[DatasetInfo] = None,
    training_result: Optional[TrainingResult] = None,
    registration_result: Optional[RegistrationResult] = None,
    backtest_result: Optional[BacktestResult] = None
) -> PipelineSummary:
    """Factory for pipeline summary."""
    status = TrainingStatus.SUCCESS

    if training_result and training_result.status != TrainingStatus.SUCCESS:
        status = training_result.status

    return PipelineSummary(
        status=status,
        version=config.version,
        model_id=registration_result.model_id if registration_result else None,
        model_path=training_result.model_path if training_result else None,
        dataset_rows=dataset_info.row_count if dataset_info else 0,
        training_duration_seconds=training_result.metrics.training_duration_seconds if training_result else 0,
        best_mean_reward=training_result.metrics.best_mean_reward if training_result else 0,
        total_timesteps=training_result.metrics.total_timesteps if training_result else 0,
        backtest_sharpe=backtest_result.metrics.sharpe_ratio if backtest_result else None,
        backtest_max_drawdown=backtest_result.metrics.max_drawdown_pct if backtest_result else None,
    )
