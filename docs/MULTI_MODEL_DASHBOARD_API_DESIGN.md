# Multi-Model Trading Signals Dashboard - Backend API Design

**Date:** 2025-10-27
**Status:** Design Document
**Purpose:** Define backend APIs for multi-strategy trading signals dashboard

---

## Executive Summary

This document specifies the backend API endpoints required to power a Trading Signals Dashboard that displays real-time signals, performance metrics, equity curves, and positions for 5 trading strategies:

1. **RL_PPO** - PPO Reinforcement Learning (LSTM-based)
2. **ML_XGB** - XGBoost Classifier with meta-labeling
3. **ML_LGBM** - LightGBM Classifier with isotonic calibration
4. **LLM_CLAUDE** - Claude Sonnet 4.5 risk overlay
5. **ENSEMBLE** - Consensus/weighted combination of all models

---

## System Architecture Analysis

### Existing Backend Services

After analyzing the codebase, the following services are available:

| Service | Port | Purpose | Status |
|---------|------|---------|--------|
| `trading_api_realtime.py` | 8000 | Real-time market data + WebSocket | ✅ Production |
| `trading_analytics_api.py` | 8001 | RL metrics, performance KPIs, production gates | ✅ Production |
| `ml_analytics_api.py` | 8005 | ML model monitoring, predictions, health | ✅ Production |
| `pipeline_data_api.py` | ? | Pipeline status, data quality | ✅ Production |
| `strategy_orchestrator.py` | N/A | Multi-strategy coordinator (3 strategies) | ⚠️ Exists but not deployed |

### Database Infrastructure

**Multi-Strategy Tables (Already Created):**

```sql
-- Strategy dimension
dw.dim_strategy (strategy_id, strategy_code, strategy_name, strategy_type)

-- Time-series hypertables
dw.fact_strategy_signals (timestamp_utc, strategy_id, signal, confidence, entry_price, etc.)
dw.fact_equity_curve (timestamp_utc, strategy_id, equity_value, return_since_start_pct, etc.)

-- Current state tables
dw.fact_strategy_positions (position_id, strategy_id, side, entry_price, unrealized_pnl, etc.)
dw.fact_strategy_performance (date_cot, strategy_id, sharpe_ratio, win_rate, etc.)

-- View
dw.vw_portfolio_summary (strategy_code, current_equity, open_positions, etc.)
```

**Market Data:**
- `usdcop_m5_ohlcv` - Main OHLCV table (hypertable)
- `trading_metrics` - General metrics storage

---

## Data Strategy

### Where Data Comes From

| Data Type | Source | Notes |
|-----------|--------|-------|
| **Market prices** | `usdcop_m5_ohlcv` table | Real OHLCV data from TwelveData API |
| **Signals** | `dw.fact_strategy_signals` | Generated by strategy orchestrator |
| **Equity curves** | `dw.fact_equity_curve` | Time-series, updated per bar |
| **Positions** | `dw.fact_strategy_positions` | Current open positions |
| **Performance metrics** | `dw.fact_strategy_performance` | Daily aggregated metrics |
| **Strategy metadata** | `dw.dim_strategy` | Strategy names, types, config |

### Simulation Strategy (Before L5/L6 Deployed)

Since L5 (Serving) and L6 (Backtesting) are not yet executed in production, we have **3 options**:

#### Option 1: Simulated Trading (Recommended for MVP)
- Run `strategy_orchestrator.py` in **paper trading mode**
- Process historical data from `usdcop_m5_ohlcv` (last 30 days)
- Generate signals and equity curves using simplified strategy logic
- Store results in `dw.fact_*` tables
- **Advantage:** Real-looking data, instant results, no model dependencies
- **Disadvantage:** Not actual model predictions, simplified logic

#### Option 2: Historical Backtest
- Run L6 backtest DAG on historical L4 datasets
- Use actual trained models (if available in MinIO)
- Generate signals and equity curves from backtest
- Store in multi-strategy tables
- **Advantage:** Uses real models, realistic performance
- **Disadvantage:** Requires L4 data + trained models, slower

#### Option 3: Hybrid Approach (Best for Demo)
- **RL_PPO**: Use simplified rule-based logic (current implementation)
- **ML_XGB/LGBM**: Use feature-based scoring (current implementation)
- **LLM_CLAUDE**: Use actual Claude API with structured output (current implementation)
- **ENSEMBLE**: Weighted average of above 3
- **Advantage:** Demonstrates multi-model concept, one strategy (LLM) is real
- **Disadvantage:** RL/ML are proxies, not actual trained models

**Recommendation:** Use **Option 3 (Hybrid)** for dashboard MVP, then upgrade to Option 2 when L5/L6 are production-ready.

---

## API Endpoint Specifications

### New Service: `multi_model_trading_api.py`

**Port:** 8006
**Purpose:** Multi-model trading signals aggregation and comparison
**Dependencies:** PostgreSQL (DWH schema), strategy_orchestrator

---

### 1. Get All Strategy Signals (Latest)

**Endpoint:** `GET /api/models/signals/latest`

**Purpose:** Get the most recent signal from each strategy

**Response Schema:**
```python
class StrategySignal(BaseModel):
    strategy_code: str          # "RL_PPO", "ML_XGB", etc.
    strategy_name: str          # "PPO Reinforcement Learning"
    signal: str                 # "long", "short", "flat"
    side: str                   # "buy", "sell", "hold"
    confidence: float           # 0.0 to 1.0
    size: float                 # Position size (0.0 to 1.0)
    entry_price: Optional[float]
    stop_loss: Optional[float]
    take_profit: Optional[float]
    risk_usd: float
    reasoning: str
    timestamp: datetime
    age_seconds: int            # How old is this signal

class LatestSignalsResponse(BaseModel):
    timestamp: datetime
    market_price: float
    market_status: str          # "open", "closed", "pre_market"
    signals: List[StrategySignal]
```

**Query:**
```sql
SELECT
    ds.strategy_code,
    ds.strategy_name,
    fs.signal,
    fs.side,
    fs.confidence,
    fs.size,
    fs.entry_price,
    fs.stop_loss,
    fs.take_profit,
    fs.risk_usd,
    fs.reasoning,
    fs.timestamp_utc,
    EXTRACT(EPOCH FROM (NOW() - fs.timestamp_utc)) as age_seconds
FROM dw.fact_strategy_signals fs
JOIN dw.dim_strategy ds ON fs.strategy_id = ds.strategy_id
WHERE fs.timestamp_utc = (
    SELECT MAX(timestamp_utc)
    FROM dw.fact_strategy_signals
    WHERE strategy_id = fs.strategy_id
)
ORDER BY ds.strategy_code;
```

**Data Source:** `dw.fact_strategy_signals` (populated by strategy orchestrator)

---

### 2. Get Performance Comparison

**Endpoint:** `GET /api/models/performance/comparison`

**Purpose:** Compare performance metrics across all strategies

**Query Parameters:**
- `period` (optional): "24h", "7d", "30d", "all" (default: "30d")

**Response Schema:**
```python
class StrategyPerformance(BaseModel):
    strategy_code: str
    strategy_name: str
    strategy_type: str          # "RL", "ML", "LLM"

    # Returns
    total_return_pct: float
    daily_return_pct: float

    # Risk-adjusted returns
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float

    # Trading metrics
    total_trades: int
    win_rate: float             # 0.0 to 1.0
    profit_factor: float

    # Risk metrics
    max_drawdown_pct: float
    current_drawdown_pct: float
    volatility_pct: float

    # Position metrics
    avg_hold_time_minutes: float
    current_equity: float
    open_positions: int

class PerformanceComparisonResponse(BaseModel):
    period: str
    start_date: datetime
    end_date: datetime
    strategies: List[StrategyPerformance]
```

**Query:**
```sql
WITH latest_equity AS (
    SELECT DISTINCT ON (strategy_id)
        strategy_id,
        equity_value,
        return_since_start_pct,
        current_drawdown_pct
    FROM dw.fact_equity_curve
    WHERE timestamp_utc >= NOW() - INTERVAL '${period}'
    ORDER BY strategy_id, timestamp_utc DESC
),
performance_agg AS (
    SELECT
        strategy_id,
        AVG(daily_return_pct) as avg_daily_return,
        AVG(sharpe_ratio) as avg_sharpe,
        AVG(sortino_ratio) as avg_sortino,
        AVG(calmar_ratio) as avg_calmar,
        SUM(n_trades) as total_trades,
        AVG(win_rate) as avg_win_rate,
        AVG(max_drawdown_pct) as max_dd,
        AVG(avg_hold_time_minutes) as avg_hold_time
    FROM dw.fact_strategy_performance
    WHERE date_cot >= CURRENT_DATE - INTERVAL '${period}'
    GROUP BY strategy_id
),
open_pos AS (
    SELECT strategy_id, COUNT(*) as open_count
    FROM dw.fact_strategy_positions
    WHERE status = 'open'
    GROUP BY strategy_id
)
SELECT
    ds.strategy_code,
    ds.strategy_name,
    ds.strategy_type,
    le.equity_value as current_equity,
    le.return_since_start_pct as total_return_pct,
    pa.avg_daily_return as daily_return_pct,
    pa.avg_sharpe as sharpe_ratio,
    pa.avg_sortino as sortino_ratio,
    pa.avg_calmar as calmar_ratio,
    pa.total_trades,
    pa.avg_win_rate as win_rate,
    pa.max_dd as max_drawdown_pct,
    le.current_drawdown_pct,
    pa.avg_hold_time as avg_hold_time_minutes,
    COALESCE(op.open_count, 0) as open_positions
FROM dw.dim_strategy ds
LEFT JOIN latest_equity le ON ds.strategy_id = le.strategy_id
LEFT JOIN performance_agg pa ON ds.strategy_id = pa.strategy_id
LEFT JOIN open_pos op ON ds.strategy_id = op.strategy_id
WHERE ds.is_active = TRUE
ORDER BY ds.strategy_code;
```

**Data Source:** `dw.fact_equity_curve`, `dw.fact_strategy_performance`, `dw.fact_strategy_positions`

---

### 3. Get Equity Curves

**Endpoint:** `GET /api/models/equity-curves`

**Purpose:** Get historical equity data for charting

**Query Parameters:**
- `hours` (optional): Number of hours to fetch (default: 24, max: 720 = 30 days)
- `strategies` (optional): Comma-separated list of strategy codes (default: all)
- `resolution` (optional): "5m", "1h", "1d" (default: "5m")

**Response Schema:**
```python
class EquityPoint(BaseModel):
    timestamp: datetime
    equity_value: float
    return_pct: float           # Return since start
    drawdown_pct: float

class EquityCurve(BaseModel):
    strategy_code: str
    strategy_name: str
    data: List[EquityPoint]
    summary: Dict[str, float]   # {starting_equity, ending_equity, total_return_pct}

class EquityCurvesResponse(BaseModel):
    start_date: datetime
    end_date: datetime
    resolution: str
    curves: List[EquityCurve]
```

**Query:**
```sql
-- For 5m resolution (no aggregation)
SELECT
    ds.strategy_code,
    ds.strategy_name,
    ec.timestamp_utc,
    ec.equity_value,
    ec.return_since_start_pct,
    ec.current_drawdown_pct
FROM dw.fact_equity_curve ec
JOIN dw.dim_strategy ds ON ec.strategy_id = ds.strategy_id
WHERE ec.timestamp_utc >= NOW() - INTERVAL '${hours} hours'
  AND (ds.strategy_code = ANY(${strategies}) OR ${strategies} IS NULL)
ORDER BY ds.strategy_code, ec.timestamp_utc;

-- For 1h or 1d resolution (time_bucket aggregation)
SELECT
    ds.strategy_code,
    ds.strategy_name,
    time_bucket('${resolution}', ec.timestamp_utc) as timestamp,
    LAST(ec.equity_value, ec.timestamp_utc) as equity_value,
    LAST(ec.return_since_start_pct, ec.timestamp_utc) as return_pct,
    LAST(ec.current_drawdown_pct, ec.timestamp_utc) as drawdown_pct
FROM dw.fact_equity_curve ec
JOIN dw.dim_strategy ds ON ec.strategy_id = ds.strategy_id
WHERE ec.timestamp_utc >= NOW() - INTERVAL '${hours} hours'
  AND (ds.strategy_code = ANY(${strategies}) OR ${strategies} IS NULL)
GROUP BY ds.strategy_code, ds.strategy_name, time_bucket('${resolution}', ec.timestamp_utc)
ORDER BY ds.strategy_code, timestamp;
```

**Data Source:** `dw.fact_equity_curve` (hypertable with time_bucket support)

---

### 4. Get Current Positions

**Endpoint:** `GET /api/models/positions/current`

**Purpose:** Get all open positions across strategies

**Query Parameters:**
- `strategy` (optional): Filter by strategy code

**Response Schema:**
```python
class Position(BaseModel):
    position_id: int
    strategy_code: str
    strategy_name: str
    side: str                   # "long", "short"
    quantity: float
    entry_price: float
    current_price: float
    stop_loss: Optional[float]
    take_profit: Optional[float]
    unrealized_pnl: float
    unrealized_pnl_pct: float
    entry_time: datetime
    holding_time_minutes: int
    leverage: int

class CurrentPositionsResponse(BaseModel):
    timestamp: datetime
    total_positions: int
    total_notional: float
    total_pnl: float
    positions: List[Position]
```

**Query:**
```sql
WITH current_price AS (
    SELECT close FROM usdcop_m5_ohlcv
    ORDER BY time DESC LIMIT 1
)
SELECT
    fp.position_id,
    ds.strategy_code,
    ds.strategy_name,
    fp.side,
    fp.quantity,
    fp.entry_price,
    cp.close as current_price,
    fp.stop_loss,
    fp.take_profit,
    fp.unrealized_pnl,
    (fp.unrealized_pnl / (fp.entry_price * fp.quantity)) * 100 as unrealized_pnl_pct,
    fp.entry_time,
    EXTRACT(EPOCH FROM (NOW() - fp.entry_time)) / 60 as holding_time_minutes,
    fp.leverage
FROM dw.fact_strategy_positions fp
JOIN dw.dim_strategy ds ON fp.strategy_id = ds.strategy_id
CROSS JOIN current_price cp
WHERE fp.status = 'open'
  AND (ds.strategy_code = ${strategy} OR ${strategy} IS NULL)
ORDER BY fp.entry_time DESC;
```

**Data Source:** `dw.fact_strategy_positions`, `usdcop_m5_ohlcv`

---

### 5. Get P&L Summary

**Endpoint:** `GET /api/models/pnl/summary`

**Purpose:** Get P&L breakdown per strategy

**Query Parameters:**
- `period` (optional): "today", "week", "month", "all" (default: "today")

**Response Schema:**
```python
class StrategyPnL(BaseModel):
    strategy_code: str
    strategy_name: str

    # P&L
    gross_profit: float
    gross_loss: float
    net_profit: float
    total_fees: float

    # Trade stats
    n_trades: int
    n_wins: int
    n_losses: int
    win_rate: float

    # Average metrics
    avg_win: float
    avg_loss: float
    avg_trade: float
    profit_factor: float

class PnLSummaryResponse(BaseModel):
    period: str
    start_date: datetime
    end_date: datetime
    strategies: List[StrategyPnL]
    portfolio_total: float
```

**Query:**
```sql
SELECT
    ds.strategy_code,
    ds.strategy_name,
    SUM(sp.gross_profit) as gross_profit,
    SUM(sp.gross_loss) as gross_loss,
    SUM(sp.net_profit) as net_profit,
    SUM(sp.total_fees) as total_fees,
    SUM(sp.n_trades) as n_trades,
    SUM(sp.n_wins) as n_wins,
    SUM(sp.n_losses) as n_losses,
    AVG(sp.win_rate) as win_rate,
    AVG(CASE WHEN sp.n_wins > 0 THEN sp.gross_profit / sp.n_wins ELSE 0 END) as avg_win,
    AVG(CASE WHEN sp.n_losses > 0 THEN sp.gross_loss / sp.n_losses ELSE 0 END) as avg_loss,
    AVG(CASE WHEN sp.n_trades > 0 THEN sp.net_profit / sp.n_trades ELSE 0 END) as avg_trade,
    AVG(CASE WHEN sp.gross_loss <> 0 THEN sp.gross_profit / ABS(sp.gross_loss) ELSE 0 END) as profit_factor
FROM dw.fact_strategy_performance sp
JOIN dw.dim_strategy ds ON sp.strategy_id = ds.strategy_id
WHERE sp.date_cot >= ${start_date}
  AND sp.date_cot <= ${end_date}
GROUP BY ds.strategy_code, ds.strategy_name
ORDER BY net_profit DESC;
```

**Data Source:** `dw.fact_strategy_performance`

---

### 6. WebSocket: Real-Time Trading Signals

**Endpoint:** `WebSocket /ws/trading-signals`

**Purpose:** Stream real-time signals, price updates, and position changes

**Message Types:**

```python
# Type 1: New Signal
{
    "type": "signal",
    "timestamp": "2025-10-27T10:30:00Z",
    "strategy_code": "RL_PPO",
    "signal": "long",
    "confidence": 0.87,
    "size": 0.75,
    "entry_price": 4320.50,
    "reasoning": "Strong momentum + RSI oversold"
}

# Type 2: Price Update
{
    "type": "price_update",
    "timestamp": "2025-10-27T10:30:00Z",
    "price": 4320.50,
    "change": 2.30,
    "change_percent": 0.05
}

# Type 3: Position Update
{
    "type": "position_update",
    "timestamp": "2025-10-27T10:30:00Z",
    "strategy_code": "ML_LGBM",
    "position_id": 12345,
    "action": "opened",  # "opened", "closed", "modified"
    "side": "long",
    "unrealized_pnl": 125.50
}

# Type 4: Equity Update
{
    "type": "equity_update",
    "timestamp": "2025-10-27T10:30:00Z",
    "equity_curves": {
        "RL_PPO": 10250.30,
        "ML_LGBM": 10180.50,
        "LLM_CLAUDE": 10050.20
    }
}
```

**Implementation:** Subscribe to PostgreSQL NOTIFY/LISTEN or poll every 5 minutes (aligned with market data updates)

---

## Pydantic Schemas (Complete)

```python
# schemas.py

from pydantic import BaseModel, Field
from typing import List, Optional, Dict
from datetime import datetime
from enum import Enum

# ============================================================
# ENUMS
# ============================================================

class SignalType(str, Enum):
    LONG = "long"
    SHORT = "short"
    FLAT = "flat"
    CLOSE = "close"

class SideType(str, Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"

class StrategyTypeEnum(str, Enum):
    RL = "RL"
    ML = "ML"
    LLM = "LLM"
    ENSEMBLE = "ENSEMBLE"

class MarketStatus(str, Enum):
    OPEN = "open"
    CLOSED = "closed"
    PRE_MARKET = "pre_market"

class PositionStatus(str, Enum):
    OPEN = "open"
    CLOSED = "closed"
    STOPPED = "stopped"

# ============================================================
# REQUEST/RESPONSE MODELS
# ============================================================

# 1. Latest Signals
class StrategySignal(BaseModel):
    strategy_code: str
    strategy_name: str
    signal: SignalType
    side: SideType
    confidence: float = Field(ge=0, le=1)
    size: float = Field(ge=0, le=1)
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    risk_usd: float
    reasoning: str
    timestamp: datetime
    age_seconds: int

class LatestSignalsResponse(BaseModel):
    timestamp: datetime
    market_price: float
    market_status: MarketStatus
    signals: List[StrategySignal]

# 2. Performance Comparison
class StrategyPerformance(BaseModel):
    strategy_code: str
    strategy_name: str
    strategy_type: StrategyTypeEnum

    # Returns
    total_return_pct: float
    daily_return_pct: float

    # Risk-adjusted
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float

    # Trading
    total_trades: int
    win_rate: float = Field(ge=0, le=1)
    profit_factor: float

    # Risk
    max_drawdown_pct: float
    current_drawdown_pct: float
    volatility_pct: float

    # Position
    avg_hold_time_minutes: float
    current_equity: float
    open_positions: int

class PerformanceComparisonResponse(BaseModel):
    period: str
    start_date: datetime
    end_date: datetime
    strategies: List[StrategyPerformance]

# 3. Equity Curves
class EquityPoint(BaseModel):
    timestamp: datetime
    equity_value: float
    return_pct: float
    drawdown_pct: float

class EquityCurve(BaseModel):
    strategy_code: str
    strategy_name: str
    data: List[EquityPoint]
    summary: Dict[str, float]

class EquityCurvesResponse(BaseModel):
    start_date: datetime
    end_date: datetime
    resolution: str
    curves: List[EquityCurve]

# 4. Current Positions
class Position(BaseModel):
    position_id: int
    strategy_code: str
    strategy_name: str
    side: str
    quantity: float
    entry_price: float
    current_price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    unrealized_pnl: float
    unrealized_pnl_pct: float
    entry_time: datetime
    holding_time_minutes: int
    leverage: int

class CurrentPositionsResponse(BaseModel):
    timestamp: datetime
    total_positions: int
    total_notional: float
    total_pnl: float
    positions: List[Position]

# 5. P&L Summary
class StrategyPnL(BaseModel):
    strategy_code: str
    strategy_name: str
    gross_profit: float
    gross_loss: float
    net_profit: float
    total_fees: float
    n_trades: int
    n_wins: int
    n_losses: int
    win_rate: float
    avg_win: float
    avg_loss: float
    avg_trade: float
    profit_factor: float

class PnLSummaryResponse(BaseModel):
    period: str
    start_date: datetime
    end_date: datetime
    strategies: List[StrategyPnL]
    portfolio_total: float

# 6. WebSocket Messages
class WSMessage(BaseModel):
    type: str
    timestamp: datetime

class SignalMessage(WSMessage):
    type: str = "signal"
    strategy_code: str
    signal: SignalType
    confidence: float
    size: float
    entry_price: float
    reasoning: str

class PriceUpdateMessage(WSMessage):
    type: str = "price_update"
    price: float
    change: float
    change_percent: float

class PositionUpdateMessage(WSMessage):
    type: str = "position_update"
    strategy_code: str
    position_id: int
    action: str  # "opened", "closed", "modified"
    side: str
    unrealized_pnl: float

class EquityUpdateMessage(WSMessage):
    type: str = "equity_update"
    equity_curves: Dict[str, float]
```

---

## Implementation Plan

### Phase 1: Data Generation (1-2 days)

**Goal:** Populate multi-strategy tables with simulated trading data

**Tasks:**
1. ✅ Verify `dw.*` schema exists (already created in `07-create-multi-strategy-tables.sql`)
2. ✅ Verify strategy dimension has 5 strategies (add XGB + ENSEMBLE)
3. Deploy `strategy_orchestrator.py` as background service
4. Create `backfill_strategy_data.py` script:
   - Process last 30 days of `usdcop_m5_ohlcv` data
   - Generate signals using 3 strategies (RL, LGBM, LLM)
   - Create XGB strategy (copy of LGBM with different parameters)
   - Create ENSEMBLE strategy (weighted average)
   - Insert into `fact_strategy_signals`, `fact_equity_curve`, `fact_strategy_positions`
5. Run backfill script to populate tables

**Deliverables:**
- `/home/azureuser/USDCOP-RL-Models/scripts/backfill_strategy_data.py`
- Updated `init-scripts/04-seed-dimensions.sql` with 5 strategies
- Populated multi-strategy tables with 30 days of data

---

### Phase 2: API Implementation (2-3 days)

**Goal:** Create new FastAPI service with all endpoints

**Tasks:**
1. Create `services/multi_model_trading_api.py`
2. Implement 5 REST endpoints:
   - `/api/models/signals/latest`
   - `/api/models/performance/comparison`
   - `/api/models/equity-curves`
   - `/api/models/positions/current`
   - `/api/models/pnl/summary`
3. Implement WebSocket endpoint `/ws/trading-signals`
4. Add Dockerfile and docker-compose entry
5. Write unit tests (`tests/test_multi_model_api.py`)

**Deliverables:**
- `services/multi_model_trading_api.py` (new FastAPI app)
- `services/Dockerfile.multi-model-api`
- Updated `docker-compose.yml`
- `services/requirements-multi-model-api.txt`

---

### Phase 3: Integration & Testing (1 day)

**Goal:** Verify APIs return correct data and integrate with dashboard

**Tasks:**
1. Start multi-model API service: `docker compose up multi-model-api`
2. Test all endpoints with Postman/curl
3. Verify data consistency (equity curves match performance metrics)
4. Test WebSocket connections (subscribe, receive updates)
5. Load testing (100+ concurrent requests)

**Deliverables:**
- `tests/test_multi_model_api_integration.py`
- `docs/API_REFERENCE_MULTI_MODEL.md` (endpoint documentation)

---

## Data Simulation Details

### Strategy Implementations

**RL_PPO (Simplified):**
```python
# Rule-based proxy for PPO
if momentum > 0.02 and rsi < 70:
    signal = "long"
    confidence = min(0.9, abs(momentum) / 0.05)
elif momentum < -0.02 and rsi > 30:
    signal = "short"
    confidence = min(0.9, abs(momentum) / 0.05)
else:
    signal = "flat"
```

**ML_LGBM (Feature-based):**
```python
# Weighted feature scoring
score = sum(feature_normalized[f] * weight[f] for f in features)
if score > 0.15:
    signal = "long"
elif score < -0.15:
    signal = "short"
else:
    signal = "flat"
```

**ML_XGB (Similar to LGBM):**
```python
# Same as LGBM but with different weights/thresholds
# Slightly more aggressive (threshold = 0.12 instead of 0.15)
```

**LLM_CLAUDE (Actual API):**
```python
# Real Claude API call with structured output
response = anthropic.messages.create(
    model="claude-sonnet-4.5-20250929",
    system="You are a risk management overlay...",
    messages=[{"role": "user", "content": market_context}]
)
# Parse JSON response with signal, confidence, reasoning
```

**ENSEMBLE (Weighted Vote):**
```python
# Weighted average of all 4 strategies
weights = {"RL_PPO": 0.3, "ML_LGBM": 0.25, "ML_XGB": 0.25, "LLM_CLAUDE": 0.2}
ensemble_score = sum(signal[s] * weights[s] for s in strategies)
if ensemble_score > 0.3:
    signal = "long"
elif ensemble_score < -0.3:
    signal = "short"
else:
    signal = "flat"
```

### Equity Curve Generation

For each 5-minute bar:
1. Get signal from strategy
2. If signal changes (flat → long, long → short, etc.):
   - Close previous position (if any) at current price
   - Calculate realized P&L
   - Open new position at current price
3. Mark-to-market open position
4. Update equity = cash + unrealized P&L
5. Insert into `fact_equity_curve`

**Simplified P&L Calculation:**
```python
if position == "long":
    pnl = (current_price - entry_price) * size * notional
elif position == "short":
    pnl = (entry_price - current_price) * size * notional
equity = starting_capital + cumulative_realized_pnl + unrealized_pnl
```

---

## CORS & Security

All APIs should allow:
```python
allow_origins = [
    "http://localhost:3000",
    "http://localhost:5000",
    "http://127.0.0.1:3000",
    "http://127.0.0.1:5000"
]
```

No authentication required for MVP (add JWT auth in production).

---

## Performance Considerations

1. **Equity Curves:** Use TimescaleDB `time_bucket()` for aggregation when fetching > 24 hours
2. **Caching:** Cache performance metrics (5-minute TTL) using Redis
3. **WebSocket:** Use PostgreSQL NOTIFY/LISTEN or Redis pub/sub for real-time updates
4. **Connection Pooling:** Use `psycopg2.pool` with 10-20 connections

---

## Testing Strategy

**Unit Tests:**
- Test each endpoint with mocked database
- Validate Pydantic schemas
- Test error handling (no data, invalid parameters)

**Integration Tests:**
- Test against real database with test data
- Verify SQL queries return expected shape
- Test WebSocket connection lifecycle

**Load Tests:**
- 100 concurrent requests to `/api/models/signals/latest`
- 50 WebSocket connections simultaneously
- Verify response time < 100ms (P95)

---

## Next Steps

1. **Review & Approve** this design document
2. **Add strategies to dimension table:**
   ```sql
   INSERT INTO dw.dim_strategy (strategy_code, strategy_name, strategy_type) VALUES
   ('ML_XGB', 'XGBoost Classifier', 'ML'),
   ('ENSEMBLE', 'Multi-Model Ensemble', 'ENSEMBLE');
   ```
3. **Implement Phase 1:** Data generation script
4. **Implement Phase 2:** FastAPI service
5. **Implement Phase 3:** Integration testing

---

## Appendix: Sample API Responses

### `/api/models/signals/latest`
```json
{
  "timestamp": "2025-10-27T10:30:00Z",
  "market_price": 4320.50,
  "market_status": "open",
  "signals": [
    {
      "strategy_code": "RL_PPO",
      "strategy_name": "PPO Reinforcement Learning",
      "signal": "long",
      "side": "buy",
      "confidence": 0.87,
      "size": 0.75,
      "entry_price": 4320.50,
      "stop_loss": 4310.20,
      "take_profit": 4335.80,
      "risk_usd": 150.00,
      "reasoning": "Strong upward momentum, RSI 42, MACD crossover",
      "timestamp": "2025-10-27T10:30:00Z",
      "age_seconds": 0
    },
    {
      "strategy_code": "ML_LGBM",
      "strategy_name": "LightGBM Classifier",
      "signal": "long",
      "side": "buy",
      "confidence": 0.82,
      "size": 0.65,
      "entry_price": 4320.50,
      "stop_loss": 4312.00,
      "take_profit": 4333.00,
      "risk_usd": 130.00,
      "reasoning": "ML Score: 0.35, High feature confidence",
      "timestamp": "2025-10-27T10:30:00Z",
      "age_seconds": 0
    },
    {
      "strategy_code": "LLM_CLAUDE",
      "strategy_name": "Claude Risk Overlay",
      "signal": "long",
      "side": "buy",
      "confidence": 0.75,
      "size": 0.50,
      "entry_price": 4320.50,
      "stop_loss": 4315.00,
      "take_profit": 4330.00,
      "risk_usd": 100.00,
      "reasoning": "Confirmed RL and ML bullish signals, volatility acceptable",
      "timestamp": "2025-10-27T10:30:00Z",
      "age_seconds": 0
    }
  ]
}
```

### `/api/models/performance/comparison`
```json
{
  "period": "30d",
  "start_date": "2025-09-27T00:00:00Z",
  "end_date": "2025-10-27T23:59:59Z",
  "strategies": [
    {
      "strategy_code": "RL_PPO",
      "strategy_name": "PPO Reinforcement Learning",
      "strategy_type": "RL",
      "total_return_pct": 15.3,
      "daily_return_pct": 0.51,
      "sharpe_ratio": 1.87,
      "sortino_ratio": 2.34,
      "calmar_ratio": 1.53,
      "total_trades": 87,
      "win_rate": 0.68,
      "profit_factor": 2.1,
      "max_drawdown_pct": -10.0,
      "current_drawdown_pct": -2.3,
      "volatility_pct": 8.2,
      "avg_hold_time_minutes": 75.5,
      "current_equity": 11530.00,
      "open_positions": 1
    },
    {
      "strategy_code": "ML_LGBM",
      "strategy_name": "LightGBM Classifier",
      "strategy_type": "ML",
      "total_return_pct": 12.8,
      "daily_return_pct": 0.43,
      "sharpe_ratio": 1.65,
      "sortino_ratio": 2.10,
      "calmar_ratio": 1.28,
      "total_trades": 102,
      "win_rate": 0.64,
      "profit_factor": 1.9,
      "max_drawdown_pct": -10.0,
      "current_drawdown_pct": -3.1,
      "volatility_pct": 7.8,
      "avg_hold_time_minutes": 62.3,
      "current_equity": 11280.00,
      "open_positions": 0
    }
  ]
}
```

---

**Document Version:** 1.0
**Last Updated:** 2025-10-27
**Author:** Claude Code
**Status:** Ready for Implementation
