/**
 * Export Manager for ChartPro
 * High-quality export functionality for PNG, SVG, and PDF
 */

import { IChartApi } from 'lightweight-charts';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import canvas2svg from 'canvas2svg';

export interface ExportOptions {
  format: 'png' | 'svg' | 'pdf';
  quality?: number; // 0.1 to 1.0 for compression
  width?: number;
  height?: number;
  scale?: number; // DPI scaling factor
  backgroundColor?: string;
  filename?: string;
  includeWatermark?: boolean;
  watermarkText?: string;
  timestamp?: boolean;
  metadata?: ExportMetadata;
}

export interface ExportMetadata {
  symbol?: string;
  timeframe?: string;
  period?: string;
  indicators?: string[];
  generated?: Date;
  application?: string;
}

export interface ExportResult {
  success: boolean;
  data?: string; // Base64 data URL or blob URL
  blob?: Blob;
  error?: string;
  metadata?: ExportMetadata;
}

export class ExportManager {
  private chart: IChartApi;
  private container: HTMLElement;

  constructor(chart: IChartApi, container: HTMLElement) {
    this.chart = chart;
    this.container = container;
  }

  public async export(
    format: 'png' | 'svg' | 'pdf',
    options: Partial<ExportOptions> = {}
  ): Promise<ExportResult> {
    const exportOptions: ExportOptions = {
      format,
      quality: options.quality || 0.9,
      scale: options.scale || 2,
      backgroundColor: options.backgroundColor || '#ffffff',
      filename: options.filename || `chart_${Date.now()}`,
      includeWatermark: options.includeWatermark || false,
      watermarkText: options.watermarkText || 'Generated by ChartPro',
      timestamp: options.timestamp !== false,
      metadata: {
        application: 'ChartPro',
        generated: new Date(),
        ...options.metadata
      },
      ...options
    };

    try {
      switch (format) {
        case 'png':
          return await this.exportToPNG(exportOptions);
        case 'svg':
          return await this.exportToSVG(exportOptions);
        case 'pdf':
          return await this.exportToPDF(exportOptions);
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown export error'
      };
    }
  }

  private async exportToPNG(options: ExportOptions): Promise<ExportResult> {
    // Create a high-quality canvas capture
    const canvas = await this.captureToCanvas(options);

    // Add watermark if requested
    if (options.includeWatermark) {
      this.addWatermarkToCanvas(canvas, options);
    }

    // Convert to PNG
    const dataURL = canvas.toDataURL('image/png', options.quality);
    const blob = await this.dataURLToBlob(dataURL);

    // Download the file
    this.downloadBlob(blob, `${options.filename}.png`);

    return {
      success: true,
      data: dataURL,
      blob,
      metadata: options.metadata
    };
  }

  private async exportToSVG(options: ExportOptions): Promise<ExportResult> {
    // Create SVG context using canvas2svg
    const rect = this.container.getBoundingClientRect();
    const width = options.width || rect.width * (options.scale || 2);
    const height = options.height || rect.height * (options.scale || 2);

    const svgContext = new canvas2svg(width, height);

    // Render chart to SVG context
    await this.renderToSVGContext(svgContext, options);

    // Add watermark if requested
    if (options.includeWatermark) {
      this.addWatermarkToSVG(svgContext, options);
    }

    // Get SVG data
    const svgData = svgContext.getSerializedSvg(true);
    const blob = new Blob([svgData], { type: 'image/svg+xml' });

    // Download the file
    this.downloadBlob(blob, `${options.filename}.svg`);

    return {
      success: true,
      data: `data:image/svg+xml;base64,${btoa(svgData)}`,
      blob,
      metadata: options.metadata
    };
  }

  private async exportToPDF(options: ExportOptions): Promise<ExportResult> {
    // Create high-quality canvas
    const canvas = await this.captureToCanvas(options);

    // Add watermark if requested
    if (options.includeWatermark) {
      this.addWatermarkToCanvas(canvas, options);
    }

    // Create PDF
    const pdf = new jsPDF({
      orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
      unit: 'px',
      format: [canvas.width, canvas.height]
    });

    // Add chart image to PDF
    const imgData = canvas.toDataURL('image/png', options.quality);
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);

    // Add metadata if available
    if (options.metadata) {
      this.addMetadataToPDF(pdf, options.metadata, canvas.width, canvas.height);
    }

    // Add timestamp if requested
    if (options.timestamp) {
      this.addTimestampToPDF(pdf, canvas.width, canvas.height);
    }

    // Get PDF blob
    const pdfBlob = pdf.output('blob');

    // Download the file
    this.downloadBlob(pdfBlob, `${options.filename}.pdf`);

    return {
      success: true,
      data: pdf.output('datauristring'),
      blob: pdfBlob,
      metadata: options.metadata
    };
  }

  private async captureToCanvas(options: ExportOptions): Promise<HTMLCanvasElement> {
    const rect = this.container.getBoundingClientRect();

    return await html2canvas(this.container, {
      width: options.width || rect.width,
      height: options.height || rect.height,
      scale: options.scale || 2,
      backgroundColor: options.backgroundColor,
      useCORS: true,
      allowTaint: true,
      removeContainer: false,
      imageTimeout: 15000,
      logging: false,
      onclone: (clonedDoc) => {
        // Ensure styles are properly cloned
        const clonedContainer = clonedDoc.querySelector('[data-chart-container]') as HTMLElement;
        if (clonedContainer) {
          clonedContainer.style.transform = 'none';
          clonedContainer.style.animation = 'none';
        }
      }
    });
  }

  private async renderToSVGContext(svgContext: any, options: ExportOptions): Promise<void> {
    // This would need to implement SVG rendering for the chart
    // For now, we'll use canvas rendering and convert to SVG
    const canvas = await this.captureToCanvas(options);
    const imgData = canvas.toDataURL('image/png');

    svgContext.drawImage(canvas, 0, 0, canvas.width, canvas.height);
  }

  private addWatermarkToCanvas(canvas: HTMLCanvasElement, options: ExportOptions): void {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Save current state
    ctx.save();

    // Configure watermark style
    const fontSize = Math.max(12, canvas.width / 80);
    ctx.font = `${fontSize}px Arial, sans-serif`;
    ctx.fillStyle = 'rgba(128, 128, 128, 0.3)';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';

    // Position watermark
    const margin = 20;
    const x = canvas.width - margin;
    const y = canvas.height - margin;

    // Draw watermark text
    if (options.watermarkText) {
      ctx.fillText(options.watermarkText, x, y);
    }

    // Restore state
    ctx.restore();
  }

  private addWatermarkToSVG(svgContext: any, options: ExportOptions): void {
    if (!options.watermarkText) return;

    const fontSize = Math.max(12, svgContext.width / 80);
    const margin = 20;
    const x = svgContext.width - margin;
    const y = svgContext.height - margin;

    svgContext.font = `${fontSize}px Arial, sans-serif`;
    svgContext.fillStyle = 'rgba(128, 128, 128, 0.3)';
    svgContext.textAlign = 'right';
    svgContext.textBaseline = 'bottom';
    svgContext.fillText(options.watermarkText, x, y);
  }

  private addMetadataToPDF(pdf: jsPDF, metadata: ExportMetadata, width: number, height: number): void {
    pdf.setFontSize(10);
    pdf.setTextColor(100, 100, 100);

    let yPosition = 20;
    const margin = 10;

    if (metadata.symbol) {
      pdf.text(`Symbol: ${metadata.symbol}`, margin, yPosition);
      yPosition += 12;
    }

    if (metadata.timeframe) {
      pdf.text(`Timeframe: ${metadata.timeframe}`, margin, yPosition);
      yPosition += 12;
    }

    if (metadata.period) {
      pdf.text(`Period: ${metadata.period}`, margin, yPosition);
      yPosition += 12;
    }

    if (metadata.indicators && metadata.indicators.length > 0) {
      pdf.text(`Indicators: ${metadata.indicators.join(', ')}`, margin, yPosition);
      yPosition += 12;
    }
  }

  private addTimestampToPDF(pdf: jsPDF, width: number, height: number): void {
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);

    const timestamp = new Date().toLocaleString();
    const margin = 10;

    pdf.text(`Generated: ${timestamp}`, margin, height - margin);
  }

  private async dataURLToBlob(dataURL: string): Promise<Blob> {
    const response = await fetch(dataURL);
    return response.blob();
  }

  private downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Cleanup
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  // Batch export functionality
  public async exportBatch(
    formats: Array<'png' | 'svg' | 'pdf'>,
    options: Partial<ExportOptions> = {}
  ): Promise<ExportResult[]> {
    const results: ExportResult[] = [];

    for (const format of formats) {
      try {
        const result = await this.export(format, {
          ...options,
          filename: `${options.filename || 'chart'}_${format}`
        });
        results.push(result);
      } catch (error) {
        results.push({
          success: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return results;
  }

  // Print functionality
  public async print(options: Partial<ExportOptions> = {}): Promise<void> {
    const canvas = await this.captureToCanvas({
      scale: 2,
      backgroundColor: '#ffffff',
      ...options
    });

    // Create print window
    const printWindow = window.open('', '_blank');
    if (!printWindow) {
      throw new Error('Failed to open print window');
    }

    const imgData = canvas.toDataURL('image/png');

    printWindow.document.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>Chart Print</title>
          <style>
            body { margin: 0; padding: 20px; }
            img { max-width: 100%; height: auto; }
            @media print {
              body { margin: 0; padding: 0; }
              img { width: 100%; height: auto; }
            }
          </style>
        </head>
        <body>
          <img src="${imgData}" alt="Chart" onload="window.print(); window.close();">
        </body>
      </html>
    `);

    printWindow.document.close();
  }

  // Copy to clipboard functionality
  public async copyToClipboard(options: Partial<ExportOptions> = {}): Promise<boolean> {
    try {
      const canvas = await this.captureToCanvas({
        scale: 1,
        backgroundColor: '#ffffff',
        ...options
      });

      canvas.toBlob(async (blob) => {
        if (!blob) {
          throw new Error('Failed to create blob from canvas');
        }

        if (navigator.clipboard && ClipboardItem) {
          await navigator.clipboard.write([
            new ClipboardItem({
              'image/png': blob
            })
          ]);
        } else {
          // Fallback for browsers without clipboard API
          const dataURL = canvas.toDataURL('image/png');
          await navigator.clipboard.writeText(dataURL);
        }
      }, 'image/png');

      return true;
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      return false;
    }
  }

  // Get chart image as data URL
  public async getImageDataURL(
    format: 'png' | 'jpeg' = 'png',
    quality: number = 0.9,
    options: Partial<ExportOptions> = {}
  ): Promise<string> {
    const canvas = await this.captureToCanvas(options);

    if (options.includeWatermark) {
      this.addWatermarkToCanvas(canvas, { ...options, watermarkText: options.watermarkText });
    }

    return canvas.toDataURL(`image/${format}`, quality);
  }

  // Utility methods
  public static formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  public static getOptimalImageFormat(hasTransparency: boolean, isPhotographic: boolean): 'png' | 'jpeg' {
    if (hasTransparency) return 'png';
    return isPhotographic ? 'jpeg' : 'png';
  }

  public destroy(): void {
    // Cleanup any resources if needed
  }
}

export default ExportManager;