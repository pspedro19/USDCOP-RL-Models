-- Migration 041: Forecast Vol-Targeting Signals & Paper Trading
-- Created: 2026-02-15
--
-- Purpose: Store daily vol-targeting signals from the forecasting pipeline
-- and track paper trading results for live validation before go-live.
--
-- Architecture:
--   L5c Vol-Targeting DAG ──► forecast_vol_targeting_signals (1 row/day)
--                                      │
--                                      ▼
--   L6 Paper Trading DAG ──► forecast_paper_trading (1 row/day, evaluated)
--                                      │
--                                      ▼
--   Dashboard ◄──────────── v_paper_trading_performance (aggregate view)
--
-- Contract: FC-SIZE-001 (Vol-Targeting Production Infrastructure)

-- =============================================================================
-- TABLE 1: FORECAST VOL-TARGETING SIGNALS
-- =============================================================================
-- One row per trading day. Generated by forecast_l5c_vol_targeting DAG
-- after market close (13:30 COT). Signal predicts T→T+1 return.

CREATE TABLE IF NOT EXISTS forecast_vol_targeting_signals (
    id                  BIGSERIAL PRIMARY KEY,

    -- Signal identity
    signal_date         DATE NOT NULL UNIQUE,

    -- Forecast inputs
    forecast_direction  SMALLINT NOT NULL,           -- +1 or -1
    forecast_return     DOUBLE PRECISION,            -- predicted log-return from ensemble
    ensemble_strategy   VARCHAR(30) DEFAULT 'top_3', -- ensemble method used
    ensemble_models     TEXT,                        -- comma-separated model IDs (e.g. "ridge,xgboost_pure,catboost_pure")

    -- Volatility
    realized_vol_21d    DOUBLE PRECISION NOT NULL,   -- annualized 21-day realized vol

    -- Position sizing
    raw_leverage        DOUBLE PRECISION NOT NULL,   -- target_vol / realized_vol (before clipping)
    clipped_leverage    DOUBLE PRECISION NOT NULL,   -- after clip to [min_leverage, max_leverage]
    position_size       DOUBLE PRECISION NOT NULL,   -- forecast_direction * clipped_leverage

    -- Config snapshot (frozen per signal for audit)
    target_vol          DOUBLE PRECISION DEFAULT 0.15,
    max_leverage        DOUBLE PRECISION DEFAULT 2.0,
    min_leverage        DOUBLE PRECISION DEFAULT 0.5,
    vol_floor           DOUBLE PRECISION DEFAULT 0.05,
    config_version      VARCHAR(20),

    -- Metadata
    created_at          TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    CONSTRAINT chk_forecast_direction CHECK (forecast_direction IN (-1, 1)),
    CONSTRAINT chk_realized_vol_positive CHECK (realized_vol_21d > 0),
    CONSTRAINT chk_clipped_leverage_bounds CHECK (clipped_leverage >= 0)
);

COMMENT ON TABLE forecast_vol_targeting_signals IS
    'Daily vol-targeting signals from forecasting pipeline. One row per trading day, generated by L5c DAG.';
COMMENT ON COLUMN forecast_vol_targeting_signals.signal_date IS
    'Date the signal was generated (day T). Signal predicts return from T to T+1.';
COMMENT ON COLUMN forecast_vol_targeting_signals.forecast_direction IS
    '+1 (long) or -1 (short) from ensemble of top-3 models at H=1';
COMMENT ON COLUMN forecast_vol_targeting_signals.realized_vol_21d IS
    'Annualized 21-day realized volatility: std(returns[-21:]) * sqrt(252)';
COMMENT ON COLUMN forecast_vol_targeting_signals.raw_leverage IS
    'target_vol / max(realized_vol_21d, vol_floor) before clipping';
COMMENT ON COLUMN forecast_vol_targeting_signals.clipped_leverage IS
    'raw_leverage clipped to [min_leverage, max_leverage]';
COMMENT ON COLUMN forecast_vol_targeting_signals.position_size IS
    'Final position: forecast_direction * clipped_leverage. Negative = short.';

-- Index for time-series queries (most recent first)
CREATE INDEX IF NOT EXISTS idx_vol_signals_date
    ON forecast_vol_targeting_signals (signal_date DESC);


-- =============================================================================
-- TABLE 2: FORECAST PAPER TRADING
-- =============================================================================
-- One row per evaluated trading day. Filled by forecast_l6_paper_trading_monitor DAG
-- after market close (19:00 COT). Evaluates the PREVIOUS day's signal.

CREATE TABLE IF NOT EXISTS forecast_paper_trading (
    id                      BIGSERIAL PRIMARY KEY,

    -- Link to signal (the signal being evaluated)
    signal_date             DATE NOT NULL UNIQUE,

    -- Denormalized signal fields (for self-contained queries)
    signal_direction        SMALLINT NOT NULL,        -- +1 or -1
    signal_leverage         DOUBLE PRECISION NOT NULL, -- clipped_leverage from signal

    -- Prices
    entry_price             DOUBLE PRECISION,          -- close on signal_date (day T)
    close_price             DOUBLE PRECISION,          -- close on day T+1

    -- Returns
    actual_return_1d        DOUBLE PRECISION,          -- log(close[T+1] / close[T])
    strategy_return         DOUBLE PRECISION,          -- direction * leverage * actual_return_1d
    tracking_error          DOUBLE PRECISION,          -- strategy_return - backtest_expected (if available)

    -- Running statistics (updated each day)
    cumulative_return       DOUBLE PRECISION,          -- running product of (1 + strategy_return)
    running_da_pct          DOUBLE PRECISION,          -- direction accuracy so far
    running_sharpe          DOUBLE PRECISION,          -- annualized Sharpe so far
    running_max_drawdown    DOUBLE PRECISION,          -- worst peak-to-trough drawdown so far
    n_days_traded           INTEGER,                   -- count of evaluated days

    -- Metadata
    created_at              TIMESTAMPTZ DEFAULT NOW(),

    -- Constraints
    CONSTRAINT chk_paper_direction CHECK (signal_direction IN (-1, 1)),
    CONSTRAINT chk_paper_leverage_positive CHECK (signal_leverage >= 0)
);

COMMENT ON TABLE forecast_paper_trading IS
    'Daily paper trading results. Each row evaluates the previous day''s vol-targeting signal against actual market returns.';
COMMENT ON COLUMN forecast_paper_trading.signal_date IS
    'Date of the signal being evaluated (day T). actual_return_1d = log(close[T+1]/close[T]).';
COMMENT ON COLUMN forecast_paper_trading.actual_return_1d IS
    'Realized log-return from signal_date close to next trading day close.';
COMMENT ON COLUMN forecast_paper_trading.strategy_return IS
    'signal_direction * signal_leverage * actual_return_1d (the leveraged return).';
COMMENT ON COLUMN forecast_paper_trading.tracking_error IS
    'Difference between live strategy_return and backtest-expected return (drift monitoring).';
COMMENT ON COLUMN forecast_paper_trading.cumulative_return IS
    'Running cumulative return: product of (1 + strategy_return) across all evaluated days.';

-- Index for time-series queries
CREATE INDEX IF NOT EXISTS idx_paper_trading_date
    ON forecast_paper_trading (signal_date DESC);

-- FK to signals table
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints
                   WHERE constraint_name = 'fk_paper_trading_signal') THEN
        ALTER TABLE forecast_paper_trading
            ADD CONSTRAINT fk_paper_trading_signal
            FOREIGN KEY (signal_date)
            REFERENCES forecast_vol_targeting_signals(signal_date)
            ON DELETE CASCADE;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Could not add FK constraint fk_paper_trading_signal: %', SQLERRM;
END $$;


-- =============================================================================
-- TRIGGER: Notify on new signal
-- =============================================================================

CREATE OR REPLACE FUNCTION notify_forecast_signal_ready()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify(
        'forecast_signal_ready',
        json_build_object(
            'signal_date', NEW.signal_date,
            'direction', NEW.forecast_direction,
            'leverage', NEW.clipped_leverage,
            'position_size', NEW.position_size
        )::text
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_notify_forecast_signal ON forecast_vol_targeting_signals;
CREATE TRIGGER trg_notify_forecast_signal
    AFTER INSERT ON forecast_vol_targeting_signals
    FOR EACH ROW
    EXECUTE FUNCTION notify_forecast_signal_ready();


-- =============================================================================
-- VIEW: Paper Trading Performance (aggregate)
-- =============================================================================

CREATE OR REPLACE VIEW v_paper_trading_performance AS
WITH stats AS (
    SELECT
        COUNT(*) AS n_days,
        COUNT(*) FILTER (WHERE actual_return_1d IS NOT NULL) AS n_evaluated,

        -- Direction accuracy
        COUNT(*) FILTER (WHERE
            (signal_direction = 1 AND actual_return_1d > 0) OR
            (signal_direction = -1 AND actual_return_1d < 0)
        ) AS correct_predictions,

        -- Returns
        SUM(strategy_return) AS total_log_return,
        AVG(strategy_return) AS avg_daily_return,
        STDDEV_SAMP(strategy_return) AS std_daily_return,

        -- Profit factor
        COALESCE(SUM(strategy_return) FILTER (WHERE strategy_return > 0), 0) AS gross_profit,
        COALESCE(ABS(SUM(strategy_return) FILTER (WHERE strategy_return < 0)), 0.0001) AS gross_loss,

        -- Dates
        MIN(signal_date) AS first_date,
        MAX(signal_date) AS last_date,

        -- Latest running stats
        (SELECT running_max_drawdown FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS max_drawdown,
        (SELECT cumulative_return FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS cumulative_return,
        (SELECT running_sharpe FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS latest_sharpe,

        -- Latest signal
        (SELECT signal_direction FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS latest_direction,
        (SELECT signal_leverage FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS latest_leverage,
        (SELECT tracking_error FROM forecast_paper_trading
         ORDER BY signal_date DESC LIMIT 1) AS latest_tracking_error,

        -- Monthly breakdown
        COUNT(DISTINCT DATE_TRUNC('month', signal_date)) AS total_months,
        COUNT(DISTINCT DATE_TRUNC('month', signal_date)) FILTER (
            WHERE signal_date IN (
                SELECT signal_date FROM forecast_paper_trading sub
                GROUP BY DATE_TRUNC('month', sub.signal_date), sub.signal_date
            )
        ) AS months_with_data

    FROM forecast_paper_trading
    WHERE actual_return_1d IS NOT NULL
)
SELECT
    n_days,
    n_evaluated,

    -- DA
    CASE WHEN n_evaluated > 0
        THEN ROUND(correct_predictions::NUMERIC / n_evaluated * 100, 2)
        ELSE 0
    END AS da_pct,

    -- Returns
    ROUND(total_log_return::NUMERIC * 100, 4) AS total_return_pct,
    ROUND((EXP(total_log_return) - 1)::NUMERIC * 100, 4) AS total_return_simple_pct,
    CASE WHEN n_evaluated >= 252
        THEN ROUND(avg_daily_return::NUMERIC * 252 * 100, 4)
        ELSE ROUND(avg_daily_return::NUMERIC * 252 * 100, 4)
    END AS annualized_return_pct,

    -- Sharpe
    latest_sharpe AS sharpe_ratio,

    -- Profit Factor
    ROUND((gross_profit / gross_loss)::NUMERIC, 4) AS profit_factor,

    -- Drawdown
    ROUND(max_drawdown::NUMERIC * 100, 4) AS max_drawdown_pct,

    -- Cumulative
    ROUND(cumulative_return::NUMERIC, 6) AS cumulative_return,

    -- Date range
    first_date,
    last_date,

    -- Latest signal
    latest_direction,
    latest_leverage,
    ROUND(latest_tracking_error::NUMERIC * 100, 4) AS latest_tracking_error_pct

FROM stats;

COMMENT ON VIEW v_paper_trading_performance IS
    'Aggregated paper trading performance metrics for dashboard monitoring.';


-- =============================================================================
-- CLEANUP FUNCTION
-- =============================================================================

CREATE OR REPLACE FUNCTION cleanup_old_vol_signals(days_to_keep INTEGER DEFAULT 365)
RETURNS BIGINT AS $$
DECLARE
    deleted_count BIGINT;
BEGIN
    -- Delete old signals that are beyond retention period
    -- Paper trading rows cascade-delete via FK
    DELETE FROM forecast_vol_targeting_signals
    WHERE signal_date < CURRENT_DATE - days_to_keep;

    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION cleanup_old_vol_signals(INTEGER) IS
    'Remove vol-targeting signals older than N days. Paper trading rows cascade-delete via FK.';
